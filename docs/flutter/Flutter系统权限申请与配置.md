# Flutter ç³»ç»Ÿæƒé™ç”³è¯·ä¸é…ç½®è¯¦è§£

## å¼•è¨€ï¼šæƒé™ç®¡ç†åœ¨ç°ä»£åº”ç”¨ä¸­çš„é‡è¦æ€§

æƒé™ç®¡ç†æ˜¯ç§»åŠ¨åº”ç”¨å¼€å‘ä¸­çš„æ ¸å¿ƒç¯èŠ‚ï¼Œå®ƒä¸ä»…å…³ç³»åˆ°åº”ç”¨åŠŸèƒ½çš„æ­£å¸¸å®ç°ï¼Œè¿˜ç›´æ¥å½±å“ç”¨æˆ·ä½“éªŒå’Œåº”ç”¨çš„å®‰å…¨æ€§ã€‚éšç€ç§»åŠ¨æ“ä½œç³»ç»Ÿå¯¹ç”¨æˆ·éšç§ä¿æŠ¤çš„æ—¥ç›Šé‡è§†ï¼Œåˆç†çš„æƒé™ç”³è¯·å’Œç®¡ç†ç­–ç•¥å˜å¾—è‡³å…³é‡è¦ã€‚

æœ¬æ–‡å°†é€šè¿‡ä¸€ä¸ªå®é™…æ¡ˆä¾‹â€”â€”å¼€å‘ä¸€æ¬¾åä¸º"SecureApp"çš„å®‰å…¨æƒé™ç®¡ç†åº”ç”¨â€”â€”æ¥è¯¦ç»†ä»‹ç» Flutter ä¸­ç³»ç»Ÿæƒé™ç”³è¯·ä¸é…ç½®çš„æŠ€æœ¯ç»†èŠ‚å’Œæœ€ä½³å®è·µã€‚

## æƒé™ç®¡ç†æ¦‚è¿°

### æƒé™ç±»å‹

1. **æ™®é€šæƒé™**ï¼šå¯¹ç”¨æˆ·éšç§å½±å“è¾ƒå°çš„æƒé™ï¼Œç³»ç»Ÿè‡ªåŠ¨æˆäºˆ
2. **å±é™©æƒé™**ï¼šå¯èƒ½å½±å“ç”¨æˆ·éšç§çš„æƒé™ï¼Œéœ€è¦ç”¨æˆ·æ˜ç¡®æˆæƒ
3. **ç­¾åæƒé™**ï¼šåªæœ‰ç›¸åŒç­¾åçš„åº”ç”¨æ‰èƒ½è·å¾—çš„æƒé™
4. **ç‰¹æ®Šæƒé™**ï¼šéœ€è¦ç‰¹æ®Šå¤„ç†çš„æƒé™ï¼Œå¦‚ç³»ç»Ÿè®¾ç½®ä¿®æ”¹

### æƒé™ç”³è¯·æµç¨‹

1. **æƒé™æ£€æŸ¥**ï¼šæ£€æŸ¥åº”ç”¨æ˜¯å¦å·²è·å¾—æ‰€éœ€æƒé™
2. **æƒé™è¯·æ±‚**ï¼šå‘ç”¨æˆ·è¯·æ±‚æƒé™
3. **æƒé™å¤„ç†**ï¼šæ ¹æ®ç”¨æˆ·å“åº”å¤„ç†æƒé™ç»“æœ
4. **æƒé™å¼•å¯¼**ï¼šåœ¨æƒé™è¢«æ‹’ç»æ—¶æä¾›å¼•å¯¼è¯´æ˜

## é¡¹ç›®èƒŒæ™¯ï¼šSecureApp å®‰å…¨æƒé™ç®¡ç†åº”ç”¨

æˆ‘ä»¬çš„é¡¹ç›®æ˜¯å¼€å‘ä¸€æ¬¾åä¸º SecureApp çš„å®‰å…¨æƒé™ç®¡ç†åº”ç”¨ï¼Œæ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼š

- æ™ºèƒ½æƒé™ç”³è¯·å’Œç®¡ç†
- æƒé™çŠ¶æ€ç›‘æ§å’Œæé†’
- æƒé™ä½¿ç”¨æƒ…å†µåˆ†æ
- æƒé™å®‰å…¨è¯„ä¼°
- æƒé™é…ç½®å¤‡ä»½å’Œæ¢å¤
- æƒé™ç”³è¯·æœ€ä½³å®è·µæŒ‡å¯¼

## æŠ€æœ¯æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Flutteråº”ç”¨å±‚                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æƒé™UI  â”‚  ç›‘æ§UI  â”‚  åˆ†æUI  â”‚  è®¾ç½®UI                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  æƒé™æœåŠ¡ç®¡ç†å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              å¹³å°é€šé“æ¡¥æ¥å±‚                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Android Permission APIs  â”‚  iOS Permission APIs       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç»„ä»¶

1. **PermissionService**ï¼šæƒé™ç®¡ç†æœåŠ¡
2. **PermissionMonitorService**ï¼šæƒé™ç›‘æ§æœåŠ¡
3. **PermissionAnalyticsService**ï¼šæƒé™åˆ†ææœåŠ¡
4. **PermissionConfigService**ï¼šæƒé™é…ç½®æœåŠ¡
5. **PlatformChannel**ï¼šå¹³å°é€šé“é€šä¿¡

## å®ç°æ­¥éª¤è¯¦è§£

### ç¬¬ä¸€æ­¥ï¼šæ·»åŠ ä¾èµ–å’Œé…ç½®

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ å¿…è¦çš„ä¾èµ–åŒ…ï¼š

```yaml
dependencies:
  flutter:
    sdk: flutter
  permission_handler: ^10.2.0
  app_settings: ^5.1.1
  shared_preferences: ^2.2.0
  package_info_plus: ^4.2.0
  device_info_plus: ^9.1.0
  flutter_local_notifications: ^15.1.1
  intl: ^0.18.1
  json_annotation: ^4.8.1
  crypto: ^3.0.3
```

Android å¹³å°éœ€è¦é…ç½®æƒé™ï¼š

```xml
<!-- android/app/src/main/AndroidManifest.xml -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- ç½‘ç»œæƒé™ -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />

    <!-- å­˜å‚¨æƒé™ -->
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" />

    <!-- ç›¸æœºæƒé™ -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />

    <!-- ä½ç½®æƒé™ -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />

    <!-- è”ç³»äººæƒé™ -->
    <uses-permission android:name="android.permission.READ_CONTACTS" />
    <uses-permission android:name="android.permission.WRITE_CONTACTS" />

    <!-- çŸ­ä¿¡æƒé™ -->
    <uses-permission android:name="android.permission.SEND_SMS" />
    <uses-permission android:name="android.permission.RECEIVE_SMS" />
    <uses-permission android:name="android.permission.READ_SMS" />

    <!-- ç”µè¯æƒé™ -->
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.CALL_PHONE" />
    <uses-permission android:name="android.permission.READ_CALL_LOG" />
    <uses-permission android:name="android.permission.WRITE_CALL_LOG" />

    <!-- æ—¥å†æƒé™ -->
    <uses-permission android:name="android.permission.READ_CALENDAR" />
    <uses-permission android:name="android.permission.WRITE_CALENDAR" />

    <!-- ä¼ æ„Ÿå™¨æƒé™ -->
    <uses-permission android:name="android.permission.BODY_SENSORS" />
    <uses-permission android:name="android.permission.ACTIVITY_RECOGNITION" />

    <!-- éº¦å…‹é£æƒé™ -->
    <uses-permission android:name="android.permission.RECORD_AUDIO" />

    <!-- é€šçŸ¥æƒé™ -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

    <!-- åº”ç”¨ä½¿ç”¨ç»Ÿè®¡æƒé™ -->
    <uses-permission android:name="android.permission.PACKAGE_USAGE_STATS" />

    <!-- å®‰è£…æœªçŸ¥åº”ç”¨æƒé™ -->
    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" />

    <!-- ç³»ç»Ÿè®¾ç½®æƒé™ -->
    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />

    <!-- è“ç‰™æƒé™ -->
    <uses-permission android:name="android.permission.BLUETOOTH" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <!-- NFCæƒé™ -->
    <uses-permission android:name="android.permission.NFC" />

    <!-- Android 13+ åª’ä½“æƒé™ -->
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />
    <uses-permission android:name="android.permission.READ_MEDIA_AUDIO" />

    <application>
        <!-- æƒé™é…ç½® -->
        <meta-data
            android:name="android.max_aspect"
            android:value="2.1" />
    </application>
</manifest>
```

iOS å¹³å°éœ€è¦åœ¨ Info.plist ä¸­æ·»åŠ æƒé™è¯´æ˜ï¼š

```xml
<!-- ios/Runner/Info.plist -->
<dict>
    <!-- ç›¸æœºæƒé™ -->
    <key>NSCameraUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®ç›¸æœºæ¥æ‹æ‘„ç…§ç‰‡å’Œè§†é¢‘</string>

    <!-- éº¦å…‹é£æƒé™ -->
    <key>NSMicrophoneUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®éº¦å…‹é£æ¥å½•åˆ¶éŸ³é¢‘</string>

    <!-- ç›¸å†Œæƒé™ -->
    <key>NSPhotoLibraryUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®ç›¸å†Œæ¥é€‰æ‹©å’Œç®¡ç†ç…§ç‰‡</string>

    <!-- ä½ç½®æƒé™ -->
    <key>NSLocationWhenInUseUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®ä½ç½®æ¥æä¾›åŸºäºä½ç½®çš„æœåŠ¡</string>
    <key>NSLocationAlwaysAndWhenInUseUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®ä½ç½®æ¥æä¾›åå°ä½ç½®æœåŠ¡</string>
    <key>NSLocationAlwaysUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®ä½ç½®æ¥æä¾›åå°ä½ç½®æœåŠ¡</string>

    <!-- è”ç³»äººæƒé™ -->
    <key>NSContactsUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®è”ç³»äººæ¥æä¾›è”ç³»äººç®¡ç†åŠŸèƒ½</string>

    <!-- æ—¥å†æƒé™ -->
    <key>NSCalendarsUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®æ—¥å†æ¥æä¾›æ—¥å†ç®¡ç†åŠŸèƒ½</string>

    <!-- æé†’äº‹é¡¹æƒé™ -->
    <key>NSRemindersUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®æé†’äº‹é¡¹æ¥æä¾›æé†’åŠŸèƒ½</string>

    <!-- è¯­éŸ³è¯†åˆ«æƒé™ -->
    <key>NSSpeechRecognitionUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®è¯­éŸ³è¯†åˆ«æ¥æä¾›è¯­éŸ³è¾“å…¥åŠŸèƒ½</string>

    <!-- è“ç‰™æƒé™ -->
    <key>NSBluetoothAlwaysUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®è“ç‰™æ¥æä¾›è“ç‰™è®¾å¤‡è¿æ¥åŠŸèƒ½</string>
    <key>NSBluetoothPeripheralUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®è“ç‰™æ¥æä¾›è“ç‰™è®¾å¤‡è¿æ¥åŠŸèƒ½</string>

    <!-- å¥åº·æ•°æ®æƒé™ -->
    <key>NSHealthShareUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®å¥åº·æ•°æ®æ¥æä¾›å¥åº·ç›‘æµ‹åŠŸèƒ½</string>
    <key>NSHealthUpdateUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®å¥åº·æ•°æ®æ¥æä¾›å¥åº·ç›‘æµ‹åŠŸèƒ½</string>

    <!-- HomeKitæƒé™ -->
    <key>NSHomeKitUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®HomeKitæ¥æä¾›æ™ºèƒ½å®¶å±…æ§åˆ¶åŠŸèƒ½</string>

    <!-- è¿åŠ¨æ•°æ®æƒé™ -->
    <key>NSMotionUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®è¿åŠ¨æ•°æ®æ¥æä¾›è¿åŠ¨ç›‘æµ‹åŠŸèƒ½</string>

    <!-- æ–‡ä»¶æƒé™ -->
    <key>NSDocumentsFolderUsageDescription</key>
    <string>æ­¤åº”ç”¨éœ€è¦è®¿é—®æ–‡æ¡£æ–‡ä»¶å¤¹æ¥æä¾›æ–‡ä»¶ç®¡ç†åŠŸèƒ½</string>

    <!-- ç½‘ç»œæƒé™ -->
    <key>NSAppTransportSecurity</key>
    <dict>
        <key>NSAllowsArbitraryLoads</key>
        <true/>
    </dict>
</dict>
```

iOS å¹³å°è¿˜éœ€è¦åœ¨ Podfile ä¸­æ·»åŠ æƒé™ç›¸å…³çš„ä¾èµ–ï¼š

```ruby
# ios/Podfile
platform :ios, '12.0'

target 'Runner' do
  use_frameworks!
  use_modular_headers!

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))

  # æƒé™ç›¸å…³ä¾èµ–
  pod 'Permission-Camera', :path => '../node_modules/react-native-permissions/ios/Camera.podspec'
  pod 'Permission-Microphone', :path => '../node_modules/react-native-permissions/ios/Microphone.podspec'
  pod 'Permission-Photos', :path => '../node_modules/react-native-permissions/ios/Photos.podspec'
  pod 'Permission-Location', :path => '../node_modules/react-native-permissions/ios/Location.podspec'
  pod 'Permission-Contacts', :path => '../node_modules/react-native-permissions/ios/Contacts.podspec'
  pod 'Permission-Calendars', :path => '../node_modules/react-native-permissions/ios/Calendars.podspec'
  pod 'Permission-Reminders', :path => '../node_modules/react-native-permissions/ios/Reminders.podspec'
  pod 'Permission-Speech', :path => '../node_modules/react-native-permissions/ios/Speech.podspec'
  pod 'Permission-Bluetooth', :path => '../node_modules/react-native-permissions/ios/Bluetooth.podspec'
  pod 'Permission-Health', :path => '../node_modules/react-native-permissions/ios/Health.podspec'
  pod 'Permission-HomeKit', :path => '../node_modules/react-native-permissions/ios/HomeKit.podspec'
  pod 'Permission-Motion', :path => '../node_modules/react-native-permissions/ios/Motion.podspec'
  pod 'Permission-MediaLibrary', :path => '../node_modules/react-native-permissions/ios/MediaLibrary.podspec'
  pod 'Permission-Notifications', :path => '../node_modules/react-native-permissions/ios/Notifications.podspec'

  # iOS 14+ ç‰¹æ®Šæƒé™
  pod 'Permission-AppTrackingTransparency', :path => '../node_modules/react-native-permissions/ios/AppTrackingTransparency.podspec'

  # æœ¬åœ°ç½‘ç»œæƒé™ (iOS 14+)
  pod 'Permission-LocalNetwork', :path => '../node_modules/react-native-permissions/ios/LocalNetwork.podspec'

  target 'RunnerTests' do
    inherit! :search_paths
  end
end

# åå®‰è£…è„šæœ¬ï¼Œç”¨äºé…ç½®æƒé™
post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '12.0'

      # é…ç½®æƒé™ç›¸å…³è®¾ç½®
      if target.name.start_with?('Permission-')
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= ['$(inherited)']
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_CAMERA=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_MICROPHONE=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_PHOTOS=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_LOCATION=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_CONTACTS=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_CALENDARS=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_REMINDERS=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_SPEECH=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_BLUETOOTH=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_HEALTH=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_HOMEKIT=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_MOTION=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_MEDIA_LIBRARY=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_NOTIFICATIONS=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_APP_TRACKING_TRANSPARENCY=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_LOCAL_NETWORK=1'
      end
    end
  end
end
```

å¯¹äºä½¿ç”¨ Flutter çš„é¡¹ç›®ï¼ŒPodfile é…ç½®åº”è¯¥å¦‚ä¸‹ï¼š

```ruby
# ios/Podfile
platform :ios, '12.0'

# CocoaPods analytics sends network requests to Google Analytics
# To disable this, uncomment the following line
# ENV['COCOAPODS_DISABLE_STATS'] = 'true'

# Prevent CocoaPods from generating a Pods.xcodeproj with Xcode 12+.
install! 'cocoapods', :deterministic_uuids => false

target 'Runner' do
  use_frameworks!
  use_modular_headers!

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))

  # æƒé™ç›¸å…³é…ç½®
  pod 'permission_handler', :path => '../.symlinks/plugins/permission_handler/ios'

  # å¦‚æœéœ€è¦ç‰¹å®šæƒé™çš„é¢å¤–é…ç½®
  # pod 'AppTrackingTransparency', '~> 2.0'  # iOS 14+ å¹¿å‘Šè¿½è¸ªæƒé™
  # pod 'CoreBluetooth', '~> 1.0'            # è“ç‰™æƒé™
  # pod 'CoreLocation', '~> 1.0'              # ä½ç½®æƒé™
  # pod 'AVFoundation', '~> 1.0'             # ç›¸æœºå’Œéº¦å…‹é£æƒé™
  # pod 'Photos', '~> 1.0'                    # ç›¸å†Œæƒé™
  # pod 'Contacts', '~> 1.0'                  # è”ç³»äººæƒé™
  # pod 'EventKit', '~> 1.0'                   # æ—¥å†å’Œæé†’æƒé™
  # pod 'Speech', '~> 1.0'                    # è¯­éŸ³è¯†åˆ«æƒé™
  # pod 'HealthKit', '~> 1.0'                 # å¥åº·æ•°æ®æƒé™
  # pod 'HomeKit', '~> 1.0'                   # HomeKitæƒé™
  # pod 'CoreMotion', '~> 1.0'                 # è¿åŠ¨æ•°æ®æƒé™
  # pod 'MediaPlayer', '~> 1.0'               # åª’ä½“åº“æƒé™
  # pod 'UserNotifications', '~> 1.0'         # é€šçŸ¥æƒé™

  target 'RunnerTests' do
    inherit! :search_paths
  end
end

# åå®‰è£…è„šæœ¬ï¼Œç”¨äºé…ç½®æƒé™å’Œæ„å»ºè®¾ç½®
post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      # è®¾ç½®æœ€ä½éƒ¨ç½²ç›®æ ‡ç‰ˆæœ¬
      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '12.0'

      # é…ç½®æƒé™ç›¸å…³è®¾ç½®
      case target.name
      when 'permission_handler'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= ['$(inherited)']
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_CAMERA=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_MICROPHONE=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_PHOTOS=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_LOCATION=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_CONTACTS=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_CALENDARS=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_REMINDERS=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_SPEECH=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_BLUETOOTH=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_HEALTH=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_HOMEKIT=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_MOTION=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_MEDIA_LIBRARY=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_NOTIFICATIONS=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_APP_TRACKING_TRANSPARENCY=1'
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'PERMISSION_CRITICAL_ALERTS=1'
      end

      # ä¿®å¤ Xcode 14+ çš„æ„å»ºé—®é¢˜
      if config.build_settings['WRAPPER_EXTENSION'] == 'bundle'
        config.build_settings['DEVELOPMENT_TEAM'] = 'YourTeamID'
      end
    end
  end
end
```

### ç¬¬äºŒæ­¥ï¼šåˆ›å»ºæƒé™æ•°æ®æ¨¡å‹

```dart
// lib/models/permission_info.dart
import 'package:json_annotation/json_annotation.dart';
import 'package:permission_handler/permission_handler.dart';

part 'permission_info.g.dart';

@JsonSerializable()
class PermissionInfo {
  final Permission permission;
  final String name;
  final String description;
  final String rationale;
  final PermissionType type;
  final PermissionCategory category;
  final PermissionStatus status;
  final bool isRequired;
  final DateTime? lastRequested;
  final int requestCount;
  final bool isPermanentlyDenied;
  final bool isLimited;
  final bool isRestricted;
  final bool isProvisional;

  PermissionInfo({
    required this.permission,
    required this.name,
    required this.description,
    required this.rationale,
    required this.type,
    required this.category,
    required this.status,
    this.isRequired = false,
    this.lastRequested,
    this.requestCount = 0,
    this.isPermanentlyDenied = false,
    this.isLimited = false,
    this.isRestricted = false,
    this.isProvisional = false,
  });

  factory PermissionInfo.fromJson(Map<String, dynamic> json) => _$PermissionInfoFromJson(json);
  Map<String, dynamic> toJson() => _$PermissionInfoToJson(this);

  // è·å–æƒé™çŠ¶æ€æè¿°
  String get statusDescription {
    switch (status) {
      case PermissionStatus.granted:
        return 'å·²æˆæƒ';
      case PermissionStatus.denied:
        return 'å·²æ‹’ç»';
      case PermissionStatus.restricted:
        return 'å—é™åˆ¶';
      case PermissionStatus.limited:
        return 'æœ‰é™æˆæƒ';
      case PermissionStatus.permanentlyDenied:
        return 'æ°¸ä¹…æ‹’ç»';
      case PermissionStatus.provisional:
        return 'ä¸´æ—¶æˆæƒ';
      default:
        return 'æœªçŸ¥çŠ¶æ€';
    }
  }

  // è·å–æƒé™çŠ¶æ€å›¾æ ‡
  String get statusIcon {
    switch (status) {
      case PermissionStatus.granted:
        return 'âœ…';
      case PermissionStatus.denied:
        return 'âŒ';
      case PermissionStatus.restricted:
        return 'ğŸ”’';
      case PermissionStatus.limited:
        return 'âš ï¸';
      case PermissionStatus.permanentlyDenied:
        return 'ğŸš«';
      case PermissionStatus.provisional:
        return 'ğŸ”„';
      default:
        return 'â“';
    }
  }

  // è·å–æƒé™ç±»å‹æè¿°
  String get typeDescription {
    switch (type) {
      case PermissionType.normal:
        return 'æ™®é€šæƒé™';
      case PermissionType.dangerous:
        return 'å±é™©æƒé™';
      case PermissionType.signature:
        return 'ç­¾åæƒé™';
      case PermissionType.special:
        return 'ç‰¹æ®Šæƒé™';
    }
  }

  // è·å–æƒé™ç±»åˆ«æè¿°
  String get categoryDescription {
    switch (category) {
      case PermissionCategory.storage:
        return 'å­˜å‚¨';
      case PermissionCategory.camera:
        return 'ç›¸æœº';
      case PermissionCategory.microphone:
        return 'éº¦å…‹é£';
      case PermissionCategory.location:
        return 'ä½ç½®';
      case PermissionCategory.contacts:
        return 'è”ç³»äºº';
      case PermissionCategory.sms:
        return 'çŸ­ä¿¡';
      case PermissionCategory.phone:
        return 'ç”µè¯';
      case PermissionCategory.calendar:
        return 'æ—¥å†';
      case PermissionCategory.sensors:
        return 'ä¼ æ„Ÿå™¨';
      case PermissionCategory.bluetooth:
        return 'è“ç‰™';
      case PermissionCategory.nfc:
        return 'NFC';
      case PermissionCategory.network:
        return 'ç½‘ç»œ';
      case PermissionCategory.system:
        return 'ç³»ç»Ÿ';
      case PermissionCategory.notification:
        return 'é€šçŸ¥';
      case PermissionCategory.other:
        return 'å…¶ä»–';
    }
  }

  // æ˜¯å¦éœ€è¦ç‰¹æ®Šå¤„ç†
  bool get needsSpecialHandling {
    return isPermanentlyDenied || isRestricted || isLimited;
  }

  // æ˜¯å¦å¯ä»¥è¯·æ±‚
  bool get canRequest {
    return status == PermissionStatus.denied || status == PermissionStatus.permanentlyDenied;
  }

  // å¤åˆ¶å¹¶æ›´æ–°çŠ¶æ€
  PermissionInfo copyWith({
    PermissionStatus? status,
    DateTime? lastRequested,
    int? requestCount,
    bool? isPermanentlyDenied,
    bool? isLimited,
    bool? isRestricted,
    bool? isProvisional,
  }) {
    return PermissionInfo(
      permission: permission,
      name: name,
      description: description,
      rationale: rationale,
      type: type,
      category: category,
      status: status ?? this.status,
      isRequired: isRequired,
      lastRequested: lastRequested ?? this.lastRequested,
      requestCount: requestCount ?? this.requestCount,
      isPermanentlyDenied: isPermanentlyDenied ?? this.isPermanentlyDenied,
      isLimited: isLimited ?? this.isLimited,
      isRestricted: isRestricted ?? this.isRestricted,
      isProvisional: isProvisional ?? this.isProvisional,
    );
  }
}

// æƒé™ç±»å‹
enum PermissionType {
  normal,
  dangerous,
  signature,
  special,
}

// æƒé™ç±»åˆ«
enum PermissionCategory {
  storage,
  camera,
  microphone,
  location,
  contacts,
  sms,
  phone,
  calendar,
  sensors,
  bluetooth,
  nfc,
  network,
  system,
  notification,
  other,
}

// æƒé™ç»„
class PermissionGroup {
  final String name;
  final String description;
  final List<Permission> permissions;
  final PermissionCategory category;
  final bool isRequired;

  PermissionGroup({
    required this.name,
    required this.description,
    required this.permissions,
    required this.category,
    this.isRequired = false,
  });

  // è·å–æƒé™ç»„çŠ¶æ€
  PermissionStatus get status {
    bool allGranted = permissions.every((permission) =>
        _getPermissionStatus(permission) == PermissionStatus.granted);

    if (allGranted) return PermissionStatus.granted;

    bool anyDenied = permissions.any((permission) =>
        _getPermissionStatus(permission) == PermissionStatus.denied ||
        _getPermissionStatus(permission) == PermissionStatus.permanentlyDenied);

    if (anyDenied) return PermissionStatus.denied;

    return PermissionStatus.denied;
  }

  // è·å–æƒé™çŠ¶æ€ï¼ˆç®€åŒ–å®ç°ï¼‰
  PermissionStatus _getPermissionStatus(Permission permission) {
    // è¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„æƒé™æ£€æŸ¥
    return PermissionStatus.denied;
  }

  // è·å–æƒé™ç»„æè¿°
  String get statusDescription {
    switch (status) {
      case PermissionStatus.granted:
        return 'å·²æˆæƒ';
      case PermissionStatus.denied:
        return 'éƒ¨åˆ†æˆ–å…¨éƒ¨æœªæˆæƒ';
      default:
        return 'æœªçŸ¥çŠ¶æ€';
    }
  }
}

// æƒé™é…ç½®
class PermissionConfig {
  final Map<Permission, PermissionInfo> permissions;
  final List<PermissionGroup> groups;
  final Map<PermissionCategory, List<Permission>> categoryPermissions;

  PermissionConfig({
    required this.permissions,
    required this.groups,
    required this.categoryPermissions,
  });

  // è·å–æƒé™ä¿¡æ¯
  PermissionInfo? getPermissionInfo(Permission permission) {
    return permissions[permission];
  }

  // è·å–æƒé™ç»„
  PermissionGroup? getPermissionGroup(String name) {
    try {
      return groups.firstWhere((group) => group.name == name);
    } catch (e) {
      return null;
    }
  }

  // è·å–ç±»åˆ«æƒé™
  List<Permission> getCategoryPermissions(PermissionCategory category) {
    return categoryPermissions[category] ?? [];
  }

  // è·å–æ‰€æœ‰å¿…éœ€æƒé™
  List<Permission> get requiredPermissions {
    return permissions.entries
        .where((entry) => entry.value.isRequired)
        .map((entry) => entry.key)
        .toList();
  }

  // è·å–æ‰€æœ‰å·²æˆæƒæƒé™
  List<Permission> get grantedPermissions {
    return permissions.entries
        .where((entry) => entry.value.status == PermissionStatus.granted)
        .map((entry) => entry.key)
        .toList();
  }

  // è·å–æ‰€æœ‰æœªæˆæƒæƒé™
  List<Permission> get deniedPermissions {
    return permissions.entries
        .where((entry) => entry.value.status != PermissionStatus.granted)
        .map((entry) => entry.key)
        .toList();
  }
}

// æƒé™è¯·æ±‚ç»“æœ
class PermissionRequestResult {
  final Map<Permission, PermissionStatus> results;
  final bool allGranted;
  final bool anyGranted;
  final bool anyPermanentlyDenied;
  final bool anyDenied;
  final DateTime timestamp;

  PermissionRequestResult({
    required this.results,
    required this.timestamp,
  }) : allGranted = results.values.every((status) => status == PermissionStatus.granted),
       anyGranted = results.values.any((status) => status == PermissionStatus.granted),
       anyPermanentlyDenied = results.values.any((status) => status == PermissionStatus.permanentlyDenied),
       anyDenied = results.values.any((status) => status == PermissionStatus.denied || status == PermissionStatus.permanentlyDenied);

  // è·å–æˆæƒçš„æƒé™
  List<Permission> get grantedPermissions {
    return results.entries
        .where((entry) => entry.value == PermissionStatus.granted)
        .map((entry) => entry.key)
        .toList();
  }

  // è·å–æ‹’ç»çš„æƒé™
  List<Permission> get deniedPermissions {
    return results.entries
        .where((entry) => entry.value == PermissionStatus.denied || entry.value == PermissionStatus.permanentlyDenied)
        .map((entry) => entry.key)
        .toList();
  }

  // è·å–æ°¸ä¹…æ‹’ç»çš„æƒé™
  List<Permission> get permanentlyDeniedPermissions {
    return results.entries
        .where((entry) => entry.value == PermissionStatus.permanentlyDenied)
        .map((entry) => entry.key)
        .toList();
  }

  // è·å–ç»“æœæè¿°
  String get resultDescription {
    if (allGranted) return 'æ‰€æœ‰æƒé™å·²æˆæƒ';
    if (anyGranted) return 'éƒ¨åˆ†æƒé™å·²æˆæƒ';
    return 'æ‰€æœ‰æƒé™è¢«æ‹’ç»';
  }
}
```

### ç¬¬ä¸‰æ­¥ï¼šåˆ›å»ºæƒé™ç®¡ç†æœåŠ¡

```dart
// lib/services/permission_service.dart
import 'dart:async';
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:app_settings/app_settings.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:device_info_plus/device_info_plus.dart';
import '../models/permission_info.dart';

class PermissionService {
  static final PermissionService _instance = PermissionService._internal();
  factory PermissionService() => _instance;
  PermissionService._internal();

  static const MethodChannel _permissionChannel = MethodChannel('secure_app/permission');

  final StreamController<PermissionEvent> _permissionEventStreamController = StreamController<PermissionEvent>.broadcast();
  PermissionConfig? _permissionConfig;

  // æƒé™äº‹ä»¶æµ
  Stream<PermissionEvent> get permissionEventStream => _permissionEventStreamController.stream;

  // åˆå§‹åŒ–æƒé™æœåŠ¡
  Future<void> initialize() async {
    try {
      await _loadPermissionConfig();
      await _checkAllPermissions();
    } catch (e) {
      throw PermissionException('åˆå§‹åŒ–æƒé™æœåŠ¡å¤±è´¥: $e');
    }
  }

  // åŠ è½½æƒé™é…ç½®
  Future<void> _loadPermissionConfig() async {
    try {
      final platform = Platform.isAndroid ? 'android' : 'ios';
      final configData = await _permissionChannel.invokeMethod('loadPermissionConfig', {'platform': platform});

      final permissions = <Permission, PermissionInfo>{};
      final groups = <PermissionGroup>[];
      final categoryPermissions = <PermissionCategory, List<Permission>>{};

      // è§£ææƒé™é…ç½®
      for (final permissionData in configData['permissions']) {
        final permission = _parsePermission(permissionData['permission']);
        final permissionInfo = PermissionInfo(
          permission: permission,
          name: permissionData['name'],
          description: permissionData['description'],
          rationale: permissionData['rationale'],
          type: _parsePermissionType(permissionData['type']),
          category: _parsePermissionCategory(permissionData['category']),
          status: PermissionStatus.denied,
          isRequired: permissionData['isRequired'] ?? false,
        );

        permissions[permission] = permissionInfo;

        // æŒ‰ç±»åˆ«åˆ†ç»„
        final category = permissionInfo.category;
        if (!categoryPermissions.containsKey(category)) {
          categoryPermissions[category] = [];
        }
        categoryPermissions[category]!.add(permission);
      }

      // è§£ææƒé™ç»„
      for (final groupData in configData['groups']) {
        final groupPermissions = <Permission>[];
        for (final permissionName in groupData['permissions']) {
          final permission = _parsePermission(permissionName);
          if (permissions.containsKey(permission)) {
            groupPermissions.add(permission);
          }
        }

        groups.add(PermissionGroup(
          name: groupData['name'],
          description: groupData['description'],
          permissions: groupPermissions,
          category: _parsePermissionCategory(groupData['category']),
          isRequired: groupData['isRequired'] ?? false,
        ));
      }

      _permissionConfig = PermissionConfig(
        permissions: permissions,
        groups: groups,
        categoryPermissions: categoryPermissions,
      );
    } catch (e) {
      throw PermissionException('åŠ è½½æƒé™é…ç½®å¤±è´¥: $e');
    }
  }

  // è§£ææƒé™
  Permission _parsePermission(String permissionName) {
    switch (permissionName) {
      case 'camera':
        return Permission.camera;
      case 'microphone':
        return Permission.microphone;
      case 'storage':
        return Permission.storage;
      case 'photos':
        return Permission.photos;
      case 'videos':
        return Permission.videos;
      case 'audio':
        return Permission.audio;
      case 'contacts':
        return Permission.contacts;
      case 'location':
        return Permission.location;
      case 'locationAlways':
        return Permission.locationAlways;
      case 'locationWhenInUse':
        return Permission.locationWhenInUse;
      case 'notification':
        return Permission.notification;
      case 'phone':
        return Permission.phone;
      case 'sms':
        return Permission.sms;
      case 'calendar':
        return Permission.calendar;
      case 'sensors':
        return Permission.sensors;
      case 'bluetooth':
        return Permission.bluetooth;
      case 'bluetoothAdvertise':
        return Permission.bluetoothAdvertise;
      case 'bluetoothConnect':
        return Permission.bluetoothConnect;
      case 'bluetoothScan':
        return Permission.bluetoothScan;
      case 'nfc':
        return Permission.nfc;
      case 'criticalAlerts':
        return Permission.criticalAlerts;
      case 'appTrackingTransparency':
        return Permission.appTrackingTransparency;
      case 'feedback':
        return Permission.feedback;
      case 'mediaLibrary':
        return Permission.mediaLibrary;
      case 'photosAddOnly':
        return Permission.photosAddOnly;
      case 'reminders':
        return Permission.reminders;
      case 'speech':
        return Permission.speech;
      case 'unknown':
        return Permission.unknown;
      default:
        return Permission.unknown;
    }
  }

  // è§£ææƒé™ç±»å‹
  PermissionType _parsePermissionType(String type) {
    switch (type) {
      case 'normal':
        return PermissionType.normal;
      case 'dangerous':
        return PermissionType.dangerous;
      case 'signature':
        return PermissionType.signature;
      case 'special':
        return PermissionType.special;
      default:
        return PermissionType.dangerous;
    }
  }

  // è§£ææƒé™ç±»åˆ«
  PermissionCategory _parsePermissionCategory(String category) {
    switch (category) {
      case 'storage':
        return PermissionCategory.storage;
      case 'camera':
        return PermissionCategory.camera;
      case 'microphone':
        return PermissionCategory.microphone;
      case 'location':
        return PermissionCategory.location;
      case 'contacts':
        return PermissionCategory.contacts;
      case 'sms':
        return PermissionCategory.sms;
      case 'phone':
        return PermissionCategory.phone;
      case 'calendar':
        return PermissionCategory.calendar;
      case 'sensors':
        return PermissionCategory.sensors;
      case 'bluetooth':
        return PermissionCategory.bluetooth;
      case 'nfc':
        return PermissionCategory.nfc;
      case 'network':
        return PermissionCategory.network;
      case 'system':
        return PermissionCategory.system;
      case 'notification':
        return PermissionCategory.notification;
      default:
        return PermissionCategory.other;
    }
  }

  // æ£€æŸ¥æ‰€æœ‰æƒé™çŠ¶æ€
  Future<void> _checkAllPermissions() async {
    if (_permissionConfig == null) return;

    for (final entry in _permissionConfig!.permissions.entries) {
      final permission = entry.key;
      final permissionInfo = entry.value;

      try {
        final status = await permission.status;
        final isPermanentlyDenied = await permission.isPermanentlyDenied;
        final isLimited = await permission.isLimited;
        final isRestricted = await permission.isRestricted;

        final updatedInfo = permissionInfo.copyWith(
          status: status,
          isPermanentlyDenied: isPermanentlyDenied,
          isLimited: isLimited,
          isRestricted: isRestricted,
        );

        _permissionConfig!.permissions[permission] = updatedInfo;
      } catch (e) {
        // å¤„ç†æƒé™æ£€æŸ¥é”™è¯¯
      }
    }
  }

  // è·å–æƒé™é…ç½®
  PermissionConfig? get permissionConfig => _permissionConfig;

  // è·å–æƒé™ä¿¡æ¯
  PermissionInfo? getPermissionInfo(Permission permission) {
    return _permissionConfig?.getPermissionInfo(permission);
  }

  // æ£€æŸ¥æƒé™çŠ¶æ€
  Future<PermissionStatus> checkPermissionStatus(Permission permission) async {
    try {
      return await permission.status;
    } catch (e) {
      throw PermissionException('æ£€æŸ¥æƒé™çŠ¶æ€å¤±è´¥: $e');
    }
  }

  // è¯·æ±‚å•ä¸ªæƒé™
  Future<PermissionStatus> requestPermission(Permission permission) async {
    try {
      final status = await permission.request();

      // æ›´æ–°æƒé™ä¿¡æ¯
      final permissionInfo = getPermissionInfo(permission);
      if (permissionInfo != null) {
        final updatedInfo = permissionInfo.copyWith(
          status: status,
          lastRequested: DateTime.now(),
          requestCount: permissionInfo.requestCount + 1,
          isPermanentlyDenied: await permission.isPermanentlyDenied,
        );

        _permissionConfig!.permissions[permission] = updatedInfo;
      }

      // å‘é€æƒé™äº‹ä»¶
      _permissionEventStreamController.add(PermissionEvent(
        type: PermissionEventType.requested,
        permission: permission,
        status: status,
        timestamp: DateTime.now(),
      ));

      return status;
    } catch (e) {
      throw PermissionException('è¯·æ±‚æƒé™å¤±è´¥: $e');
    }
  }

  // è¯·æ±‚å¤šä¸ªæƒé™
  Future<PermissionRequestResult> requestPermissions(List<Permission> permissions) async {
    try {
      final results = await permissions.request();

      // æ›´æ–°æƒé™ä¿¡æ¯
      for (final entry in results.entries) {
        final permission = entry.key;
        final status = entry.value;

        final permissionInfo = getPermissionInfo(permission);
        if (permissionInfo != null) {
          final updatedInfo = permissionInfo.copyWith(
            status: status,
            lastRequested: DateTime.now(),
            requestCount: permissionInfo.requestCount + 1,
            isPermanentlyDenied: await permission.isPermanentlyDenied,
          );

          _permissionConfig!.permissions[permission] = updatedInfo;
        }

        // å‘é€æƒé™äº‹ä»¶
        _permissionEventStreamController.add(PermissionEvent(
          type: PermissionEventType.requested,
          permission: permission,
          status: status,
          timestamp: DateTime.now(),
        ));
      }

      return PermissionRequestResult(
        results: results,
        timestamp: DateTime.now(),
      );
    } catch (e) {
      throw PermissionException('è¯·æ±‚å¤šä¸ªæƒé™å¤±è´¥: $e');
    }
  }

  // è¯·æ±‚æƒé™ç»„
  Future<PermissionRequestResult> requestPermissionGroup(String groupName) async {
    final group = _permissionConfig?.getPermissionGroup(groupName);
    if (group == null) {
      throw PermissionException('æƒé™ç»„ä¸å­˜åœ¨: $groupName');
    }

    return await requestPermissions(group.permissions);
  }

  // è¯·æ±‚æ‰€æœ‰å¿…éœ€æƒé™
  Future<PermissionRequestResult> requestRequiredPermissions() async {
    final requiredPermissions = _permissionConfig?.requiredPermissions ?? [];
    return await requestPermissions(requiredPermissions);
  }

  // æ£€æŸ¥æƒé™æ˜¯å¦è¢«æ°¸ä¹…æ‹’ç»
  Future<bool> isPermanentlyDenied(Permission permission) async {
    try {
      return await permission.isPermanentlyDenied;
    } catch (e) {
      throw PermissionException('æ£€æŸ¥æƒé™æ°¸ä¹…æ‹’ç»çŠ¶æ€å¤±è´¥: $e');
    }
  }

  // æ£€æŸ¥æƒé™æ˜¯å¦å—é™
  Future<bool> isRestricted(Permission permission) async {
    try {
      return await permission.isRestricted;
    } catch (e) {
      throw PermissionException('æ£€æŸ¥æƒé™å—é™çŠ¶æ€å¤±è´¥: $e');
    }
  }

  // æ£€æŸ¥æƒé™æ˜¯å¦æœ‰é™æˆæƒ
  Future<bool> isLimited(Permission permission) async {
    try {
      return await permission.isLimited;
    } catch (e) {
      throw PermissionException('æ£€æŸ¥æƒé™æœ‰é™æˆæƒçŠ¶æ€å¤±è´¥: $e');
    }
  }

  // æ‰“å¼€åº”ç”¨è®¾ç½®
  Future<void> openAppSettings() async {
    try {
      await AppSettings.openAppSettings();
    } catch (e) {
      throw PermissionException('æ‰“å¼€åº”ç”¨è®¾ç½®å¤±è´¥: $e');
    }
  }

  // æ‰“å¼€ç‰¹å®šæƒé™è®¾ç½®
  Future<void> openPermissionSettings(Permission permission) async {
    try {
      if (Platform.isAndroid) {
        // Android æ‰“å¼€åº”ç”¨è®¾ç½®é¡µé¢
        await AppSettings.openAppSettings();
      } else {
        // iOS æ‰“å¼€ç‰¹å®šæƒé™è®¾ç½®
        await AppSettings.openAppSettings(type: _getAppSettingsType(permission));
      }
    } catch (e) {
      throw PermissionException('æ‰“å¼€æƒé™è®¾ç½®å¤±è´¥: $e');
    }
  }

  // è·å–åº”ç”¨è®¾ç½®ç±»å‹
  AppSettingsType _getAppSettingsType(Permission permission) {
    switch (permission) {
      case Permission.camera:
        return AppSettingsType.camera;
      case Permission.microphone:
        return AppSettingsType.microphone;
      case Permission.photos:
        return AppSettingsType.photos;
      case Permission.location:
        return AppSettingsType.location;
      case Permission.notification:
        return AppSettingsType.notification;
      default:
        return AppSettingsType.settings;
    }
  }

  // æ£€æŸ¥æ˜¯å¦åº”è¯¥æ˜¾ç¤ºæƒé™è¯´æ˜
  bool shouldShowRationale(Permission permission) {
    final permissionInfo = getPermissionInfo(permission);
    if (permissionInfo == null) return false;

    // é¦–æ¬¡è¯·æ±‚æˆ–è¢«æ‹’ç»ååº”è¯¥æ˜¾ç¤ºè¯´æ˜
    return permissionInfo.requestCount == 0 ||
           permissionInfo.status == PermissionStatus.denied;
  }

  // è·å–æƒé™è¯´æ˜æ–‡æœ¬
  String getRationaleText(Permission permission) {
    final permissionInfo = getPermissionInfo(permission);
    return permissionInfo?.rationale ?? 'æ­¤åº”ç”¨éœ€è¦æ­¤æƒé™æ¥æä¾›ç›¸å…³åŠŸèƒ½';
  }

  // ä¿å­˜æƒé™é…ç½®
  Future<void> savePermissionConfig() async {
    try {
      final prefs = await SharedPreferences.getInstance();

      // ä¿å­˜æƒé™çŠ¶æ€
      for (final entry in _permissionConfig!.permissions.entries) {
        final permission = entry.key;
        final permissionInfo = entry.value;

        await prefs.setString('permission_${permission.toString()}', permissionInfo.status.toString());
        await prefs.setInt('permission_${permission.toString()}_count', permissionInfo.requestCount);
        if (permissionInfo.lastRequested != null) {
          await prefs.setString('permission_${permission.toString()}_last', permissionInfo.lastRequested!.toIso8601String());
        }
      }
    } catch (e) {
      throw PermissionException('ä¿å­˜æƒé™é…ç½®å¤±è´¥: $e');
    }
  }

  // åŠ è½½æƒé™é…ç½®
  Future<void> loadPermissionConfig() async {
    try {
      final prefs = await SharedPreferences.getInstance();

      // åŠ è½½æƒé™çŠ¶æ€
      for (final entry in _permissionConfig!.permissions.entries) {
        final permission = entry.key;
        final permissionInfo = entry.value;

        final statusString = prefs.getString('permission_${permission.toString()}');
        final requestCount = prefs.getInt('permission_${permission.toString()}_count') ?? 0;
        final lastRequestedString = prefs.getString('permission_${permission.toString()}_last');

        if (statusString != null) {
          final status = _parsePermissionStatus(statusString);
          final lastRequested = lastRequestedString != null ? DateTime.parse(lastRequestedString) : null;

          final updatedInfo = permissionInfo.copyWith(
            status: status,
            requestCount: requestCount,
            lastRequested: lastRequested,
          );

          _permissionConfig!.permissions[permission] = updatedInfo;
        }
      }
    } catch (e) {
      throw PermissionException('åŠ è½½æƒé™é…ç½®å¤±è´¥: $e');
    }
  }

  // è§£ææƒé™çŠ¶æ€
  PermissionStatus _parsePermissionStatus(String statusString) {
    switch (statusString) {
      case 'granted':
        return PermissionStatus.granted;
      case 'denied':
        return PermissionStatus.denied;
      case 'restricted':
        return PermissionStatus.restricted;
      case 'limited':
        return PermissionStatus.limited;
      case 'permanentlyDenied':
        return PermissionStatus.permanentlyDenied;
      case 'provisional':
        return PermissionStatus.provisional;
      default:
        return PermissionStatus.denied;
    }
  }

  // è·å–æƒé™ç»Ÿè®¡ä¿¡æ¯
  PermissionStatistics getPermissionStatistics() {
    if (_permissionConfig == null) {
      return PermissionStatistics(
        totalPermissions: 0,
        grantedPermissions: 0,
        deniedPermissions: 0,
        permanentlyDeniedPermissions: 0,
        requiredPermissions: 0,
        requiredGrantedPermissions: 0,
      );
    }

    final totalPermissions = _permissionConfig!.permissions.length;
    final grantedPermissions = _permissionConfig!.grantedPermissions.length;
    final deniedPermissions = _permissionConfig!.deniedPermissions.length;
    final permanentlyDeniedPermissions = _permissionConfig!.permissions.values
        .where((info) => info.isPermanentlyDenied)
        .length;
    final requiredPermissions = _permissionConfig!.requiredPermissions.length;
    final requiredGrantedPermissions = _permissionConfig!.requiredPermissions
        .where((permission) => _permissionConfig!.permissions[permission]?.status == PermissionStatus.granted)
        .length;

    return PermissionStatistics(
      totalPermissions: totalPermissions,
      grantedPermissions: grantedPermissions,
      deniedPermissions: deniedPermissions,
      permanentlyDeniedPermissions: permanentlyDeniedPermissions,
      requiredPermissions: requiredPermissions,
      requiredGrantedPermissions: requiredGrantedPermissions,
    );
  }

  // é‡Šæ”¾èµ„æº
  void dispose() {
    _permissionEventStreamController.close();
  }
}

// æƒé™äº‹ä»¶
class PermissionEvent {
  final PermissionEventType type;
  final Permission permission;
  final PermissionStatus status;
  final DateTime timestamp;

  PermissionEvent({
    required this.type,
    required this.permission,
    required this.status,
    required this.timestamp,
  });
}

// æƒé™äº‹ä»¶ç±»å‹
enum PermissionEventType {
  requested,
  granted,
  denied,
  permanentlyDenied,
  restricted,
  limited,
}

// æƒé™ç»Ÿè®¡ä¿¡æ¯
class PermissionStatistics {
  final int totalPermissions;
  final int grantedPermissions;
  final int deniedPermissions;
  final int permanentlyDeniedPermissions;
  final int requiredPermissions;
  final int requiredGrantedPermissions;

  PermissionStatistics({
    required this.totalPermissions,
    required this.grantedPermissions,
    required this.deniedPermissions,
    required this.permanentlyDeniedPermissions,
    required this.requiredPermissions,
    required this.requiredGrantedPermissions,
  });

  // è·å–æˆæƒç‡
  double get grantRate {
    if (totalPermissions == 0) return 0.0;
    return grantedPermissions / totalPermissions;
  }

  // è·å–å¿…éœ€æƒé™æˆæƒç‡
  double get requiredGrantRate {
    if (requiredPermissions == 0) return 0.0;
    return requiredGrantedPermissions / requiredPermissions;
  }

  // è·å–æ ¼å¼åŒ–çš„æˆæƒç‡
  String get formattedGrantRate {
    return '${(grantRate * 100).toStringAsFixed(1)}%';
  }

  // è·å–æ ¼å¼åŒ–çš„å¿…éœ€æƒé™æˆæƒç‡
  String get formattedRequiredGrantRate {
    return '${(requiredGrantRate * 100).toStringAsFixed(1)}%';
  }
}

// æƒé™å¼‚å¸¸
class PermissionException implements Exception {
  final String message;
  PermissionException(this.message);

  @override
  String toString() => message;
}
```

### ç¬¬å››æ­¥ï¼šå®ç° Android åŸç”Ÿä»£ç 

```kotlin
// android/app/src/main/kotlin/com/example/secure_app/PermissionPlugin.kt
package com.example.secure_app

import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel

class PermissionPlugin(private val context: Context) : MethodChannel.MethodCallHandler {

    override fun onMethodCall(call: MethodCall, result: MethodChannel.Result) {
        when (call.method) {
            "loadPermissionConfig" -> {
                result.success(loadPermissionConfig(call.argument("platform") ?: "android"))
            }
            "checkPermissionStatus" -> {
                result.success(checkPermissionStatus(call.argument("permission") ?: ""))
            }
            "openPermissionSettings" -> {
                result.success(openPermissionSettings(call.argument("permission") ?: ""))
            }
            else -> {
                result.notImplemented()
            }
        }
    }

    private fun loadPermissionConfig(platform: String): Map<String, Any> {
        return mapOf(
            "permissions" to getPermissionConfig(),
            "groups" to getPermissionGroups()
        )
    }

    private fun getPermissionConfig(): List<Map<String, Any>> {
        return listOf(
            mapOf(
                "permission" to "camera",
                "name" to "ç›¸æœº",
                "description" to "è®¿é—®ç›¸æœºæ‹æ‘„ç…§ç‰‡å’Œè§†é¢‘",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦ç›¸æœºæƒé™æ¥æ‹æ‘„ç…§ç‰‡å’Œè§†é¢‘ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ä½¿ç”¨æ‹ç…§åŠŸèƒ½",
                "type" to "dangerous",
                "category" to "camera",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "microphone",
                "name" to "éº¦å…‹é£",
                "description" to "è®¿é—®éº¦å…‹é£å½•åˆ¶éŸ³é¢‘",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦éº¦å…‹é£æƒé™æ¥å½•åˆ¶éŸ³é¢‘ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ä½¿ç”¨å½•éŸ³åŠŸèƒ½",
                "type" to "dangerous",
                "category" to "microphone",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "storage",
                "name" to "å­˜å‚¨",
                "description" to "è®¿é—®è®¾å¤‡å­˜å‚¨ç©ºé—´",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦å­˜å‚¨æƒé™æ¥ä¿å­˜å’Œè¯»å–æ–‡ä»¶ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ç®¡ç†æ–‡ä»¶",
                "type" to "dangerous",
                "category" to "storage",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "location",
                "name" to "ä½ç½®",
                "description" to "è®¿é—®è®¾å¤‡ä½ç½®ä¿¡æ¯",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦ä½ç½®æƒé™æ¥æä¾›åŸºäºä½ç½®çš„æœåŠ¡ï¼Œå¦‚å¯¼èˆªå’Œä½ç½®æ ‡è®°",
                "type" to "dangerous",
                "category" to "location",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "contacts",
                "name" to "è”ç³»äºº",
                "description" to "è®¿é—®è®¾å¤‡è”ç³»äºº",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦è”ç³»äººæƒé™æ¥ç®¡ç†è”ç³»äººï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ä½¿ç”¨è”ç³»äººåŠŸèƒ½",
                "type" to "dangerous",
                "category" to "contacts",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "phone",
                "name" to "ç”µè¯",
                "description" to "è®¿é—®ç”µè¯åŠŸèƒ½",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦ç”µè¯æƒé™æ¥æ‹¨æ‰“ç”µè¯å’Œè¯»å–é€šè¯è®°å½•",
                "type" to "dangerous",
                "category" to "phone",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "sms",
                "name" to "çŸ­ä¿¡",
                "description" to "è®¿é—®çŸ­ä¿¡åŠŸèƒ½",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦çŸ­ä¿¡æƒé™æ¥å‘é€å’Œæ¥æ”¶çŸ­ä¿¡",
                "type" to "dangerous",
                "category" to "sms",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "calendar",
                "name" to "æ—¥å†",
                "description" to "è®¿é—®æ—¥å†åŠŸèƒ½",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦æ—¥å†æƒé™æ¥ç®¡ç†æ—¥ç¨‹å®‰æ’",
                "type" to "dangerous",
                "category" to "calendar",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "sensors",
                "name" to "ä¼ æ„Ÿå™¨",
                "description" to "è®¿é—®è®¾å¤‡ä¼ æ„Ÿå™¨",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦ä¼ æ„Ÿå™¨æƒé™æ¥ç›‘æµ‹è®¾å¤‡çŠ¶æ€å’Œç¯å¢ƒ",
                "type" to "dangerous",
                "category" to "sensors",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "bluetooth",
                "name" to "è“ç‰™",
                "description" to "è®¿é—®è“ç‰™åŠŸèƒ½",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦è“ç‰™æƒé™æ¥è¿æ¥è“ç‰™è®¾å¤‡",
                "type" to "dangerous",
                "category" to "bluetooth",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "nfc",
                "name" to "NFC",
                "description" to "è®¿é—®NFCåŠŸèƒ½",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦NFCæƒé™æ¥è¯»å–NFCæ ‡ç­¾",
                "type" to "dangerous",
                "category" to "nfc",
                "isRequired" to false
            ),
            mapOf(
                "permission" to "notification",
                "name" to "é€šçŸ¥",
                "description" to "å‘é€é€šçŸ¥",
                "rationale" to "æ­¤åº”ç”¨éœ€è¦é€šçŸ¥æƒé™æ¥å‘é€é‡è¦ä¿¡æ¯æé†’",
                "type" to if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) "dangerous" else "normal",
                "category" to "notification",
                "isRequired" to false
            )
        )
    }

    private fun getPermissionGroups(): List<Map<String, Any>> {
        return listOf(
            mapOf(
                "name" to "åª’ä½“æƒé™",
                "description" to "ç›¸æœºã€éº¦å…‹é£å’Œå­˜å‚¨æƒé™",
                "permissions" to listOf("camera", "microphone", "storage"),
                "category" to "media",
                "isRequired" to false
            ),
            mapOf(
                "name" to "ä½ç½®æƒé™",
                "description" to "ä½ç½®ç›¸å…³æƒé™",
                "permissions" to listOf("location"),
                "category" to "location",
                "isRequired" to false
            ),
            mapOf(
                "name" to "é€šä¿¡æƒé™",
                "description" to "è”ç³»äººã€ç”µè¯å’ŒçŸ­ä¿¡æƒé™",
                "permissions" to listOf("contacts", "phone", "sms"),
                "category" to "communication",
                "isRequired" to false
            ),
            mapOf(
                "name" to "è®¾å¤‡æƒé™",
                "description" to "ä¼ æ„Ÿå™¨ã€è“ç‰™å’ŒNFCæƒé™",
                "permissions" to listOf("sensors", "bluetooth", "nfc"),
                "category" to "device",
                "isRequired" to false
            ),
            mapOf(
                "name" to "ç³»ç»Ÿæƒé™",
                "description" to "æ—¥å†å’Œé€šçŸ¥æƒé™",
                "permissions" to listOf("calendar", "notification"),
                "category" to "system",
                "isRequired" to false
            )
        )
    }

    private fun checkPermissionStatus(permission: String): String {
        val androidPermission = getAndroidPermission(permission)
        return when (ContextCompat.checkSelfPermission(context, androidPermission)) {
            PackageManager.PERMISSION_GRANTED -> "granted"
            PackageManager.PERMISSION_DENIED -> "denied"
            else -> "denied"
        }
    }

    private fun getAndroidPermission(permission: String): String {
        return when (permission) {
            "camera" -> android.Manifest.permission.CAMERA
            "microphone" -> android.Manifest.permission.RECORD_AUDIO
            "storage" -> if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                android.Manifest.permission.READ_MEDIA_IMAGES
            } else {
                android.Manifest.permission.READ_EXTERNAL_STORAGE
            }
            "location" -> android.Manifest.permission.ACCESS_FINE_LOCATION
            "contacts" -> android.Manifest.permission.READ_CONTACTS
            "phone" -> android.Manifest.permission.READ_PHONE_STATE
            "sms" -> android.Manifest.permission.READ_SMS
            "calendar" -> android.Manifest.permission.READ_CALENDAR
            "sensors" -> android.Manifest.permission.BODY_SENSORS
            "bluetooth" -> if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                android.Manifest.permission.BLUETOOTH_CONNECT
            } else {
                android.Manifest.permission.BLUETOOTH
            }
            "nfc" -> android.Manifest.permission.NFC
            "notification" -> if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                android.Manifest.permission.POST_NOTIFICATIONS
            } else {
                ""
            }
            else -> ""
        }
    }

    private fun openPermissionSettings(permission: String): Boolean {
        return try {
            val intent = android.content.Intent(android.content.Intent.ACTION_APPLICATION_DETAILS_SETTINGS)
            intent.data = android.net.Uri.fromParts("package", context.packageName, null)
            intent.flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK
            context.startActivity(intent)
            true
        } catch (e: Exception) {
            false
        }
    }
}
```

### ç¬¬äº”æ­¥ï¼šå®ç° iOS åŸç”Ÿä»£ç 

```swift
// ios/Runner/PermissionPlugin.swift
import Foundation
import UIKit
import AVFoundation
import Photos
import CoreLocation
import Contacts
import EventKit
import CoreBluetooth
import CoreMotion
import UserNotifications

class PermissionPlugin: NSObject, FlutterPlugin {

    static func register(with registrar: FlutterPluginRegistrar) {
        let channel = FlutterMethodChannel(name: "secure_app/permission", binaryMessenger: registrar.messenger())
        let instance = PermissionPlugin()
        registrar.addMethodCallDelegate(instance, channel: channel)
    }

    func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
        switch call.method {
        case "loadPermissionConfig":
            result(loadPermissionConfig(call.arguments as? [String: Any]? ?? [:]))
        case "checkPermissionStatus":
            result(checkPermissionStatus(call.arguments as? String ?? ""))
        case "openPermissionSettings":
            result(openPermissionSettings(call.arguments as? String ?? ""))
        default:
            result(FlutterMethodNotImplemented)
        }
    }

    private func loadPermissionConfig(_ arguments: [String: Any]) -> [String: Any] {
        return [
            "permissions": getPermissionConfig(),
            "groups": getPermissionGroups()
        ]
    }

    private func getPermissionConfig() -> [[String: Any]] {
        return [
            [
                "permission": "camera",
                "name": "ç›¸æœº",
                "description": "è®¿é—®ç›¸æœºæ‹æ‘„ç…§ç‰‡å’Œè§†é¢‘",
                "rationale": "æ­¤åº”ç”¨éœ€è¦ç›¸æœºæƒé™æ¥æ‹æ‘„ç…§ç‰‡å’Œè§†é¢‘ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ä½¿ç”¨æ‹ç…§åŠŸèƒ½",
                "type": "dangerous",
                "category": "camera",
                "isRequired": false
            ],
            [
                "permission": "microphone",
                "name": "éº¦å…‹é£",
                "description": "è®¿é—®éº¦å…‹é£å½•åˆ¶éŸ³é¢‘",
                "rationale": "æ­¤åº”ç”¨éœ€è¦éº¦å…‹é£æƒé™æ¥å½•åˆ¶éŸ³é¢‘ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ä½¿ç”¨å½•éŸ³åŠŸèƒ½",
                "type": "dangerous",
                "category": "microphone",
                "isRequired": false
            ],
            [
                "permission": "photos",
                "name": "ç›¸å†Œ",
                "description": "è®¿é—®ç›¸å†Œä¸­çš„ç…§ç‰‡å’Œè§†é¢‘",
                "rationale": "æ­¤åº”ç”¨éœ€è¦ç›¸å†Œæƒé™æ¥é€‰æ‹©å’Œç®¡ç†ç…§ç‰‡ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ä½¿ç”¨ç›¸å†ŒåŠŸèƒ½",
                "type": "dangerous",
                "category": "storage",
                "isRequired": false
            ],
            [
                "permission": "location",
                "name": "ä½ç½®",
                "description": "è®¿é—®è®¾å¤‡ä½ç½®ä¿¡æ¯",
                "rationale": "æ­¤åº”ç”¨éœ€è¦ä½ç½®æƒé™æ¥æä¾›åŸºäºä½ç½®çš„æœåŠ¡ï¼Œå¦‚å¯¼èˆªå’Œä½ç½®æ ‡è®°",
                "type": "dangerous",
                "category": "location",
                "isRequired": false
            ],
            [
                "permission": "contacts",
                "name": "è”ç³»äºº",
                "description": "è®¿é—®è®¾å¤‡è”ç³»äºº",
                "rationale": "æ­¤åº”ç”¨éœ€è¦è”ç³»äººæƒé™æ¥ç®¡ç†è”ç³»äººï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ä½¿ç”¨è”ç³»äººåŠŸèƒ½",
                "type": "dangerous",
                "category": "contacts",
                "isRequired": false
            ],
            [
                "permission": "calendar",
                "name": "æ—¥å†",
                "description": "è®¿é—®æ—¥å†åŠŸèƒ½",
                "rationale": "æ­¤åº”ç”¨éœ€è¦æ—¥å†æƒé™æ¥ç®¡ç†æ—¥ç¨‹å®‰æ’",
                "type": "dangerous",
                "category": "calendar",
                "isRequired": false
            ],
            [
                "permission": "bluetooth",
                "name": "è“ç‰™",
                "description": "è®¿é—®è“ç‰™åŠŸèƒ½",
                "rationale": "æ­¤åº”ç”¨éœ€è¦è“ç‰™æƒé™æ¥è¿æ¥è“ç‰™è®¾å¤‡",
                "type": "dangerous",
                "category": "bluetooth",
                "isRequired": false
            ],
            [
                "permission": "notification",
                "name": "é€šçŸ¥",
                "description": "å‘é€é€šçŸ¥",
                "rationale": "æ­¤åº”ç”¨éœ€è¦é€šçŸ¥æƒé™æ¥å‘é€é‡è¦ä¿¡æ¯æé†’",
                "type": "dangerous",
                "category": "notification",
                "isRequired": false
            ],
            [
                "permission": "sensors",
                "name": "ä¼ æ„Ÿå™¨",
                "description": "è®¿é—®è®¾å¤‡ä¼ æ„Ÿå™¨",
                "rationale": "æ­¤åº”ç”¨éœ€è¦ä¼ æ„Ÿå™¨æƒé™æ¥ç›‘æµ‹è®¾å¤‡çŠ¶æ€å’Œç¯å¢ƒ",
                "type": "dangerous",
                "category": "sensors",
                "isRequired": false
            ],
            [
                "permission": "speech",
                "name": "è¯­éŸ³è¯†åˆ«",
                "description": "è®¿é—®è¯­éŸ³è¯†åˆ«åŠŸèƒ½",
                "rationale": "æ­¤åº”ç”¨éœ€è¦è¯­éŸ³è¯†åˆ«æƒé™æ¥æä¾›è¯­éŸ³è¾“å…¥åŠŸèƒ½",
                "type": "dangerous",
                "category": "microphone",
                "isRequired": false
            ],
            [
                "permission": "mediaLibrary",
                "name": "åª’ä½“åº“",
                "description": "è®¿é—®åª’ä½“åº“",
                "rationale": "æ­¤åº”ç”¨éœ€è¦åª’ä½“åº“æƒé™æ¥ç®¡ç†åª’ä½“æ–‡ä»¶",
                "type": "dangerous",
                "category": "storage",
                "isRequired": false
            ]
        ]
    }

    private func getPermissionGroups() -> [[String: Any]] {
        return [
            [
                "name": "åª’ä½“æƒé™",
                "description": "ç›¸æœºã€éº¦å…‹é£å’Œç›¸å†Œæƒé™",
                "permissions": ["camera", "microphone", "photos"],
                "category": "media",
                "isRequired": false
            ],
            [
                "name": "ä½ç½®æƒé™",
                "description": "ä½ç½®ç›¸å…³æƒé™",
                "permissions": ["location"],
                "category": "location",
                "isRequired": false
            ],
            [
                "name": "é€šä¿¡æƒé™",
                "description": "è”ç³»äººå’Œæ—¥å†æƒé™",
                "permissions": ["contacts", "calendar"],
                "category": "communication",
                "isRequired": false
            ],
            [
                "name": "è®¾å¤‡æƒé™",
                "description": "ä¼ æ„Ÿå™¨å’Œè“ç‰™æƒé™",
                "permissions": ["sensors", "bluetooth"],
                "category": "device",
                "isRequired": false
            ],
            [
                "name": "ç³»ç»Ÿæƒé™",
                "description": "é€šçŸ¥å’Œè¯­éŸ³è¯†åˆ«æƒé™",
                "permissions": ["notification", "speech"],
                "category": "system",
                "isRequired": false
            ]
        ]
    }

    private func checkPermissionStatus(_ permission: String) -> String {
        switch permission {
        case "camera":
            return checkCameraPermission()
        case "microphone":
            return checkMicrophonePermission()
        case "photos":
            return checkPhotosPermission()
        case "location":
            return checkLocationPermission()
        case "contacts":
            return checkContactsPermission()
        case "calendar":
            return checkCalendarPermission()
        case "bluetooth":
            return checkBluetoothPermission()
        case "notification":
            return checkNotificationPermission()
        case "sensors":
            return checkSensorsPermission()
        case "speech":
            return checkSpeechPermission()
        case "mediaLibrary":
            return checkMediaLibraryPermission()
        default:
            return "denied"
        }
    }

    private func checkCameraPermission() -> String {
        let status = AVCaptureDevice.authorizationStatus(for: .video)
        switch status {
        case .authorized:
            return "granted"
        case .denied:
            return "denied"
        case .restricted:
            return "restricted"
        case .notDetermined:
            return "denied"
        @unknown default:
            return "denied"
        }
    }

    private func checkMicrophonePermission() -> String {
        let status = AVCaptureDevice.authorizationStatus(for: .audio)
        switch status {
        case .authorized:
            return "granted"
        case .denied:
            return "denied"
        case .restricted:
            return "restricted"
        case .notDetermined:
            return "denied"
        @unknown default:
            return "denied"
        }
    }

    private func checkPhotosPermission() -> String {
        let status = PHPhotoLibrary.authorizationStatus()
        switch status {
        case .authorized:
            return "granted"
        case .denied:
            return "denied"
        case .restricted:
            return "restricted"
        case .notDetermined:
            return "denied"
        case .limited:
            return "limited"
        @unknown default:
            return "denied"
        }
    }

    private func checkLocationPermission() -> String {
        let status = CLLocationManager.authorizationStatus()
        switch status {
        case .authorizedAlways:
            return "granted"
        case .authorizedWhenInUse:
            return "granted"
        case .denied:
            return "denied"
        case .restricted:
            return "restricted"
        case .notDetermined:
            return "denied"
        @unknown default:
            return "denied"
        }
    }

    private func checkContactsPermission() -> String {
        let status = CNContactStore.authorizationStatus(for: .contacts)
        switch status {
        case .authorized:
            return "granted"
        case .denied:
            return "denied"
        case .restricted:
            return "restricted"
        case .notDetermined:
            return "denied"
        @unknown default:
            return "denied"
        }
    }

    private func checkCalendarPermission() -> String {
        let status = EKEventStore.authorizationStatus(for: .event)
        switch status {
        case .authorized:
            return "granted"
        case .denied:
            return "denied"
        case .restricted:
            return "restricted"
        case .notDetermined:
            return "denied"
        @unknown default:
            return "denied"
        }
    }

    private func checkBluetoothPermission() -> String {
        if #available(iOS 13.0, *) {
            let status = CBCentralManager.authorization
            switch status {
            case .allowedAlways:
                return "granted"
            case .denied:
                return "denied"
            case .restricted:
                return "restricted"
            case .notDetermined:
                return "denied"
            @unknown default:
                return "denied"
            }
        } else {
            return "granted"
        }
    }

    private func checkNotificationPermission() -> String {
        if #available(iOS 10.0, *) {
            let center = UNUserNotificationCenter.current()
            var notificationSettings: UNNotificationSettings?
            let semaphore = DispatchSemaphore(value: 0)

            center.getNotificationSettings { settings in
                notificationSettings = settings
                semaphore.signal()
            }

            semaphore.wait()

            guard let settings = notificationSettings else {
                return "denied"
            }

            switch settings.authorizationStatus {
            case .authorized:
                return "granted"
            case .denied:
                return "denied"
            case .provisional:
                return "provisional"
            case .notDetermined:
                return "denied"
            case .ephemeral:
                return "granted"
            @unknown default:
                return "denied"
            }
        } else {
            return "granted"
        }
    }

    private func checkSensorsPermission() -> String {
        if #available(iOS 11.0, *) {
            let status = CMMotionActivityManager.authorizationStatus()
            switch status {
            case .authorized:
                return "granted"
            case .denied:
                return "denied"
            case .restricted:
                return "restricted"
            case .notDetermined:
                return "denied"
            @unknown default:
                return "denied"
            }
        } else {
            return "granted"
        }
    }

    private func checkSpeechPermission() -> String {
        if #available(iOS 10.0, *) {
            let status = SFSpeechRecognizer.authorizationStatus()
            switch status {
            case .authorized:
                return "granted"
            case .denied:
                return "denied"
            case .restricted:
                return "restricted"
            case .notDetermined:
                return "denied"
            @unknown default:
                return "denied"
            }
        } else {
            return "granted"
        }
    }

    private func checkMediaLibraryPermission() -> String {
        if #available(iOS 9.3, *) {
            let status = MPMediaLibrary.authorizationStatus()
            switch status {
            case .authorized:
                return "granted"
            case .denied:
                return "denied"
            case .restricted:
                return "restricted"
            case .notDetermined:
                return "denied"
            @unknown default:
                return "denied"
            }
        } else {
            return "granted"
        }
    }

    private func openPermissionSettings(_ permission: String) -> Bool {
        guard let settingsUrl = URL(string: UIApplication.openSettingsURLString) else {
            return false
        }

        if UIApplication.shared.canOpenURL(settingsUrl) {
            UIApplication.shared.open(settingsUrl, completionHandler: nil)
            return true
        }

        return false
    }
}
```

### ç¬¬å…­æ­¥ï¼šåˆ›å»ºä¸»åº”ç”¨ç•Œé¢

```dart
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart';
import 'widgets/permission_list_widget.dart';
import 'widgets/permission_group_widget.dart';
import 'widgets/permission_statistics_widget.dart';
import 'models/permission_info.dart';
import 'services/permission_service.dart';

void main() {
  runApp(const SecureApp());
}

class SecureApp extends StatelessWidget {
  const SecureApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'SecureApp',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        brightness: Brightness.light,
      ),
      home: const MainScreen(),
    );
  }
}

class MainScreen extends StatefulWidget {
  const MainScreen({Key? key}) : super(key: key);

  @override
  _MainScreenState createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final PermissionService _permissionService = PermissionService();

  bool _isLoading = false;
  PermissionConfig? _permissionConfig;
  PermissionStatistics? _statistics;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    _initializeApp();
  }

  @override
  void dispose() {
    _tabController.dispose();
    _permissionService.dispose();
    super.dispose();
  }

  Future<void> _initializeApp() async {
    setState(() => _isLoading = true);

    try {
      await _permissionService.initialize();
      setState(() {
        _permissionConfig = _permissionService.permissionConfig;
        _statistics = _permissionService.getPermissionStatistics();
      });
    } catch (e) {
      _showErrorSnackBar('åˆå§‹åŒ–åº”ç”¨å¤±è´¥: $e');
    } finally {
      setState(() => _isLoading = false);
    }
  }

  void _showErrorSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
      ),
    );
  }

  void _showSuccessSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.green,
      ),
    );
  }

  Future<void> _refreshPermissions() async {
    try {
      await _permissionService.initialize();
      setState(() {
        _permissionConfig = _permissionService.permissionConfig;
        _statistics = _permissionService.getPermissionStatistics();
      });
      _showSuccessSnackBar('æƒé™çŠ¶æ€å·²æ›´æ–°');
    } catch (e) {
      _showErrorSnackBar('åˆ·æ–°æƒé™çŠ¶æ€å¤±è´¥: $e');
    }
  }

  Future<void> _requestAllRequiredPermissions() async {
    try {
      final result = await _permissionService.requestRequiredPermissions();

      if (result.allGranted) {
        _showSuccessSnackBar('æ‰€æœ‰å¿…éœ€æƒé™å·²æˆæƒ');
      } else if (result.anyGranted) {
        _showSuccessSnackBar('éƒ¨åˆ†æƒé™å·²æˆæƒ');
      } else {
        _showErrorSnackBar('æ‰€æœ‰æƒé™è¢«æ‹’ç»');
      }

      await _refreshPermissions();
    } catch (e) {
      _showErrorSnackBar('è¯·æ±‚æƒé™å¤±è´¥: $e');
    }
  }

  Future<void> _openAppSettings() async {
    try {
      await _permissionService.openAppSettings();
    } catch (e) {
      _showErrorSnackBar('æ‰“å¼€è®¾ç½®å¤±è´¥: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    if (_permissionConfig == null) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('SecureApp'),
          backgroundColor: Colors.blue,
        ),
        body: const Center(
          child: Text('æ— æ³•åŠ è½½æƒé™é…ç½®'),
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('SecureApp'),
        backgroundColor: Colors.blue,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _refreshPermissions,
            tooltip: 'åˆ·æ–°',
          ),
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: _openAppSettings,
            tooltip: 'è®¾ç½®',
          ),
        ],
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(icon: Icon(Icons.list), text: 'æƒé™åˆ—è¡¨'),
            Tab(icon: Icon(Icons.category), text: 'æƒé™åˆ†ç»„'),
            Tab(icon: Icon(Icons.analytics), text: 'ç»Ÿè®¡åˆ†æ'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          // æƒé™åˆ—è¡¨é¡µé¢
          PermissionListWidget(
            permissionConfig: _permissionConfig!,
            permissionService: _permissionService,
            onRefresh: _refreshPermissions,
          ),

          // æƒé™åˆ†ç»„é¡µé¢
          PermissionGroupWidget(
            permissionConfig: _permissionConfig!,
            permissionService: _permissionService,
            onRefresh: _refreshPermissions,
          ),

          // ç»Ÿè®¡åˆ†æé¡µé¢
          PermissionStatisticsWidget(
            statistics: _statistics!,
            permissionConfig: _permissionConfig!,
            onRequestRequiredPermissions: _requestAllRequiredPermissions,
            onOpenSettings: _openAppSettings,
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _requestAllRequiredPermissions,
        child: const Icon(Icons.security),
        tooltip: 'è¯·æ±‚æ‰€æœ‰å¿…éœ€æƒé™',
      ),
    );
  }
}
```

## é«˜çº§åŠŸèƒ½å®ç°

### 1. æƒé™ç›‘æ§æœåŠ¡

```dart
// lib/services/permission_monitor_service.dart
import 'dart:async';
import 'package:flutter/services.dart';
import 'package:permission_handler/permission_handler.dart';
import '../models/permission_info.dart';
import 'permission_service.dart';

class PermissionMonitorService {
  static final PermissionMonitorService _instance = PermissionMonitorService._internal();
  factory PermissionMonitorService() => _instance;
  PermissionMonitorService._internal();

  static const MethodChannel _monitorChannel = MethodChannel('secure_app/monitor');

  final StreamController<PermissionMonitorEvent> _monitorEventStreamController = StreamController<PermissionMonitorEvent>.broadcast();
  Timer? _monitorTimer;
  Map<Permission, PermissionStatus> _lastStatusMap = {};

  // ç›‘æ§äº‹ä»¶æµ
  Stream<PermissionMonitorEvent> get monitorEventStream => _monitorEventStreamController.stream;

  // å¼€å§‹æƒé™ç›‘æ§
  void startMonitoring({Duration interval = const Duration(seconds: 30)}) {
    stopMonitoring();

    _monitorTimer = Timer.periodic(interval, (timer) async {
      await _checkPermissionChanges();
    });
  }

  // åœæ­¢æƒé™ç›‘æ§
  void stopMonitoring() {
    _monitorTimer?.cancel();
    _monitorTimer = null;
  }

  // æ£€æŸ¥æƒé™å˜åŒ–
  Future<void> _checkPermissionChanges() async {
    try {
      final permissionService = PermissionService();
      final permissionConfig = permissionService.permissionConfig;

      if (permissionConfig == null) return;

      for (final entry in permissionConfig.permissions.entries) {
        final permission = entry.key;
        final currentStatus = await permission.status;
        final lastStatus = _lastStatusMap[permission];

        if (lastStatus != null && lastStatus != currentStatus) {
          // æƒé™çŠ¶æ€å‘ç”Ÿå˜åŒ–
          _monitorEventStreamController.add(PermissionMonitorEvent(
            type: PermissionMonitorEventType.statusChanged,
            permission: permission,
            oldStatus: lastStatus,
            newStatus: currentStatus,
            timestamp: DateTime.now(),
          ));
        }

        _lastStatusMap[permission] = currentStatus;
      }
    } catch (e) {
      // å¤„ç†é”™è¯¯
    }
  }

  // è·å–æƒé™ä½¿ç”¨ç»Ÿè®¡
  Future<PermissionUsageStatistics> getPermissionUsageStatistics() async {
    try {
      final usageData = await _monitorChannel.invokeMethod('getPermissionUsageStatistics');

      return PermissionUsageStatistics(
        totalUsageTime: Duration(milliseconds: usageData['totalUsageTime'] ?? 0),
        permissionUsageTimes: Map.from(usageData['permissionUsageTimes'] ?? {}),
        lastUsageTime: DateTime.fromMillisecondsSinceEpoch(usageData['lastUsageTime'] ?? 0),
        mostUsedPermission: usageData['mostUsedPermission'],
        usageCount: usageData['usageCount'] ?? 0,
      );
    } catch (e) {
      throw PermissionMonitorException('è·å–æƒé™ä½¿ç”¨ç»Ÿè®¡å¤±è´¥: $e');
    }
  }

  // è·å–æƒé™å®‰å…¨è¯„ä¼°
  Future<PermissionSecurityAssessment> getPermissionSecurityAssessment() async {
    try {
      final assessmentData = await _monitorChannel.invokeMethod('getPermissionSecurityAssessment');

      return PermissionSecurityAssessment(
        securityScore: assessmentData['securityScore'] ?? 0,
        riskLevel: _parseRiskLevel(assessmentData['riskLevel']),
        riskyPermissions: List<String>.from(assessmentData['riskyPermissions'] ?? []),
        recommendations: List<String>.from(assessmentData['recommendations'] ?? []),
        lastAssessmentTime: DateTime.fromMillisecondsSinceEpoch(assessmentData['lastAssessmentTime'] ?? 0),
      );
    } catch (e) {
      throw PermissionMonitorException('è·å–æƒé™å®‰å…¨è¯„ä¼°å¤±è´¥: $e');
    }
  }

  // è§£æé£é™©çº§åˆ«
  RiskLevel _parseRiskLevel(String riskLevel) {
    switch (riskLevel) {
      case 'low':
        return RiskLevel.low;
      case 'medium':
        return RiskLevel.medium;
      case 'high':
        return RiskLevel.high;
      case 'critical':
        return RiskLevel.critical;
      default:
        return RiskLevel.low;
    }
  }

  // é‡Šæ”¾èµ„æº
  void dispose() {
    stopMonitoring();
    _monitorEventStreamController.close();
  }
}

// æƒé™ç›‘æ§äº‹ä»¶
class PermissionMonitorEvent {
  final PermissionMonitorEventType type;
  final Permission permission;
  final PermissionStatus? oldStatus;
  final PermissionStatus? newStatus;
  final DateTime timestamp;

  PermissionMonitorEvent({
    required this.type,
    required this.permission,
    this.oldStatus,
    this.newStatus,
    required this.timestamp,
  });
}

// æƒé™ç›‘æ§äº‹ä»¶ç±»å‹
enum PermissionMonitorEventType {
  statusChanged,
  usageDetected,
  securityAlert,
}

// æƒé™ä½¿ç”¨ç»Ÿè®¡
class PermissionUsageStatistics {
  final Duration totalUsageTime;
  final Map<String, int> permissionUsageTimes;
  final DateTime lastUsageTime;
  final String? mostUsedPermission;
  final int usageCount;

  PermissionUsageStatistics({
    required this.totalUsageTime,
    required this.permissionUsageTimes,
    required this.lastUsageTime,
    this.mostUsedPermission,
    required this.usageCount,
  });

  // è·å–æ ¼å¼åŒ–çš„æ€»ä½¿ç”¨æ—¶é—´
  String get formattedTotalUsageTime {
    final hours = totalUsageTime.inHours;
    final minutes = totalUsageTime.inMinutes % 60;
    final seconds = totalUsageTime.inSeconds % 60;

    if (hours > 0) {
      return '${hours}å°æ—¶${minutes}åˆ†é’Ÿ';
    } else if (minutes > 0) {
      return '${minutes}åˆ†é’Ÿ${seconds}ç§’';
    } else {
      return '${seconds}ç§’';
    }
  }

  // è·å–æœ€å¸¸ç”¨æƒé™æè¿°
  String get mostUsedPermissionDescription {
    return mostUsedPermission ?? 'æ— ';
  }
}

// æƒé™å®‰å…¨è¯„ä¼°
class PermissionSecurityAssessment {
  final int securityScore;
  final RiskLevel riskLevel;
  final List<String> riskyPermissions;
  final List<String> recommendations;
  final DateTime lastAssessmentTime;

  PermissionSecurityAssessment({
    required this.securityScore,
    required this.riskLevel,
    required this.riskyPermissions,
    required this.recommendations,
    required this.lastAssessmentTime,
  });

  // è·å–å®‰å…¨åˆ†æ•°æè¿°
  String get securityScoreDescription {
    if (securityScore >= 90) return 'éå¸¸å®‰å…¨';
    if (securityScore >= 70) return 'å®‰å…¨';
    if (securityScore >= 50) return 'ä¸€èˆ¬';
    if (securityScore >= 30) return 'æœ‰é£é™©';
    return 'é«˜é£é™©';
  }

  // è·å–é£é™©çº§åˆ«æè¿°
  String get riskLevelDescription {
    switch (riskLevel) {
      case RiskLevel.low:
        return 'ä½é£é™©';
      case RiskLevel.medium:
        return 'ä¸­ç­‰é£é™©';
      case RiskLevel.high:
        return 'é«˜é£é™©';
      case RiskLevel.critical:
        return 'ä¸¥é‡é£é™©';
    }
  }
}

// é£é™©çº§åˆ«
enum RiskLevel {
  low,
  medium,
  high,
  critical,
}

// æƒé™ç›‘æ§å¼‚å¸¸
class PermissionMonitorException implements Exception {
  final String message;
  PermissionMonitorException(this.message);

  @override
  String toString() => message;
}
```

### 2. æƒé™åˆ†ææœåŠ¡

```dart
// lib/services/permission_analytics_service.dart
import 'dart:async';
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:permission_handler/permission_handler.dart';
import '../models/permission_info.dart';
import 'permission_service.dart';

class PermissionAnalyticsService {
  static final PermissionAnalyticsService _instance = PermissionAnalyticsService._internal();
  factory PermissionAnalyticsService() => _instance;
  PermissionAnalyticsService._internal();

  static const String _analyticsKey = 'permission_analytics';
  static const String _eventsKey = 'permission_events';

  List<PermissionAnalyticsEvent> _events = [];
  PermissionAnalyticsData? _analyticsData;

  // åˆå§‹åŒ–åˆ†ææœåŠ¡
  Future<void> initialize() async {
    try {
      await _loadAnalyticsData();
      await _loadEvents();
    } catch (e) {
      throw PermissionAnalyticsException('åˆå§‹åŒ–åˆ†ææœåŠ¡å¤±è´¥: $e');
    }
  }

  // è®°å½•æƒé™äº‹ä»¶
  Future<void> recordEvent(PermissionAnalyticsEvent event) async {
    try {
      _events.add(event);

      // é™åˆ¶äº‹ä»¶æ•°é‡
      if (_events.length > 1000) {
        _events = _events.sublist(_events.length - 1000);
      }

      await _saveEvents();
      await _updateAnalyticsData();
    } catch (e) {
      throw PermissionAnalyticsException('è®°å½•æƒé™äº‹ä»¶å¤±è´¥: $e');
    }
  }

  // è®°å½•æƒé™è¯·æ±‚äº‹ä»¶
  Future<void> recordPermissionRequest(
    Permission permission,
    PermissionStatus status,
    {String? context}
  ) async {
    final event = PermissionAnalyticsEvent(
      type: PermissionAnalyticsEventType.request,
      permission: permission,
      status: status,
      timestamp: DateTime.now(),
      context: context,
    );

    await recordEvent(event);
  }

  // è®°å½•æƒé™ä½¿ç”¨äº‹ä»¶
  Future<void> recordPermissionUsage(
    Permission permission,
    Duration usageDuration,
    {String? context}
  ) async {
    final event = PermissionAnalyticsEvent(
      type: PermissionAnalyticsEventType.usage,
      permission: permission,
      timestamp: DateTime.now(),
      usageDuration: usageDuration,
      context: context,
    );

    await recordEvent(event);
  }

  // è®°å½•æƒé™æ‹’ç»äº‹ä»¶
  Future<void> recordPermissionDenial(
    Permission permission,
    String reason,
    {String? context}
  ) async {
    final event = PermissionAnalyticsEvent(
      type: PermissionAnalyticsEventType.denial,
      permission: permission,
      timestamp: DateTime.now(),
      reason: reason,
      context: context,
    );

    await recordEvent(event);
  }

  // è·å–åˆ†ææ•°æ®
  PermissionAnalyticsData? get analyticsData => _analyticsData;

  // è·å–æƒé™è¯·æ±‚ç»Ÿè®¡
  Map<Permission, PermissionRequestStatistics> getPermissionRequestStatistics() {
    final statistics = <Permission, PermissionRequestStatistics>{};

    for (final event in _events) {
      if (event.type != PermissionAnalyticsEventType.request) continue;

      final permission = event.permission;
      if (!statistics.containsKey(permission)) {
        statistics[permission] = PermissionRequestStatistics(
          permission: permission,
          requestCount: 0,
          grantCount: 0,
          denialCount: 0,
          lastRequestTime: DateTime.now(),
        );
      }

      final stat = statistics[permission]!;
      stat.requestCount++;

      if (event.status == PermissionStatus.granted) {
        stat.grantCount++;
      } else {
        stat.denialCount++;
      }

      if (event.timestamp.isAfter(stat.lastRequestTime)) {
        stat.lastRequestTime = event.timestamp;
      }
    }

    return statistics;
  }

  // è·å–æƒé™ä½¿ç”¨ç»Ÿè®¡
  Map<Permission, PermissionUsageStatistics> getPermissionUsageStatistics() {
    final statistics = <Permission, PermissionUsageStatistics>{};

    for (final event in _events) {
      if (event.type != PermissionAnalyticsEventType.usage) continue;

      final permission = event.permission;
      if (!statistics.containsKey(permission)) {
        statistics[permission] = PermissionUsageStatistics(
          permission: permission,
          usageCount: 0,
          totalUsageDuration: Duration.zero,
          lastUsageTime: DateTime.now(),
        );
      }

      final stat = statistics[permission]!;
      stat.usageCount++;
      stat.totalUsageDuration += event.usageDuration ?? Duration.zero;

      if (event.timestamp.isAfter(stat.lastUsageTime)) {
        stat.lastUsageTime = event.timestamp;
      }
    }

    return statistics;
  }

  // è·å–æƒé™æ‹’ç»åˆ†æ
  PermissionDenialAnalysis getPermissionDenialAnalysis() {
    final denialEvents = _events.where((event) => event.type == PermissionAnalyticsEventType.denial);
    final reasonCounts = <String, int>{};
    final permissionDenials = <Permission, int>{};

    for (final event in denialEvents) {
      final reason = event.reason ?? 'æœªçŸ¥åŸå› ';
      reasonCounts[reason] = (reasonCounts[reason] ?? 0) + 1;

      final permission = event.permission;
      permissionDenials[permission] = (permissionDenials[permission] ?? 0) + 1;
    }

    return PermissionDenialAnalysis(
      totalDenials: denialEvents.length,
      denialReasons: reasonCounts,
      permissionDenials: permissionDenials,
      mostCommonReason: reasonCounts.entries.isNotEmpty
          ? reasonCounts.entries.reduce((a, b) => a.value > b.value ? a : b).key
          : 'æ— ',
      mostDeniedPermission: permissionDenials.entries.isNotEmpty
          ? permissionDenials.entries.reduce((a, b) => a.value > b.value ? a : b).key
          : Permission.unknown,
    );
  }

  // è·å–æƒé™è¶‹åŠ¿åˆ†æ
  PermissionTrendAnalysis getPermissionTrendAnalysis({int days = 30}) {
    final now = DateTime.now();
    final startDate = now.subtract(Duration(days: days));
    final dailyEvents = <DateTime, List<PermissionAnalyticsEvent>>{};

    for (final event in _events) {
      if (event.timestamp.isBefore(startDate)) continue;

      final day = DateTime(event.timestamp.year, event.timestamp.month, event.timestamp.day);
      if (!dailyEvents.containsKey(day)) {
        dailyEvents[day] = [];
      }
      dailyEvents[day]!.add(event);
    }

    final trendData = <DateTime, PermissionTrendData>{};

    for (final entry in dailyEvents.entries) {
      final day = entry.key;
      final events = entry.value;

      final requestCount = events.where((e) => e.type == PermissionAnalyticsEventType.request).length;
      final grantCount = events.where((e) => e.type == PermissionAnalyticsEventType.request && e.status == PermissionStatus.granted).length;
      final denialCount = events.where((e) => e.type == PermissionAnalyticsEventType.denial).length;
      final usageCount = events.where((e) => e.type == PermissionAnalyticsEventType.usage).length;

      trendData[day] = PermissionTrendData(
        date: day,
        requestCount: requestCount,
        grantCount: grantCount,
        denialCount: denialCount,
        usageCount: usageCount,
      );
    }

    return PermissionTrendAnalysis(
      period: Duration(days: days),
      trendData: trendData,
      startDate: startDate,
      endDate: now,
    );
  }

  // ç”Ÿæˆæƒé™æŠ¥å‘Š
  Future<PermissionReport> generateReport({int days = 30}) async {
    try {
      final requestStatistics = getPermissionRequestStatistics();
      final usageStatistics = getPermissionUsageStatistics();
      final denialAnalysis = getPermissionDenialAnalysis();
      final trendAnalysis = getPermissionTrendAnalysis(days: days);

      return PermissionReport(
        generatedAt: DateTime.now(),
        period: Duration(days: days),
        requestStatistics: requestStatistics,
        usageStatistics: usageStatistics,
        denialAnalysis: denialAnalysis,
        trendAnalysis: trendAnalysis,
      );
    } catch (e) {
      throw PermissionAnalyticsException('ç”Ÿæˆæƒé™æŠ¥å‘Šå¤±è´¥: $e');
    }
  }

  // å¯¼å‡ºåˆ†ææ•°æ®
  Future<String> exportAnalyticsData() async {
    try {
      final exportData = {
        'events': _events.map((e) => e.toJson()).toList(),
        'analyticsData': _analyticsData?.toJson(),
        'exportedAt': DateTime.now().toIso8601String(),
      };

      return jsonEncode(exportData);
    } catch (e) {
      throw PermissionAnalyticsException('å¯¼å‡ºåˆ†ææ•°æ®å¤±è´¥: $e');
    }
  }

  // å¯¼å…¥åˆ†ææ•°æ®
  Future<void> importAnalyticsData(String jsonData) async {
    try {
      final importData = jsonDecode(jsonData);

      if (importData['events'] != null) {
        _events = (importData['events'] as List)
            .map((e) => PermissionAnalyticsEvent.fromJson(e))
            .toList();
      }

      if (importData['analyticsData'] != null) {
        _analyticsData = PermissionAnalyticsData.fromJson(importData['analyticsData']);
      }

      await _saveEvents();
      await _saveAnalyticsData();
    } catch (e) {
      throw PermissionAnalyticsException('å¯¼å…¥åˆ†ææ•°æ®å¤±è´¥: $e');
    }
  }

  // æ¸…é™¤åˆ†ææ•°æ®
  Future<void> clearAnalyticsData() async {
    try {
      _events.clear();
      _analyticsData = null;

      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_eventsKey);
      await prefs.remove(_analyticsKey);
    } catch (e) {
      throw PermissionAnalyticsException('æ¸…é™¤åˆ†ææ•°æ®å¤±è´¥: $e');
    }
  }

  // åŠ è½½åˆ†ææ•°æ®
  Future<void> _loadAnalyticsData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final analyticsJson = prefs.getString(_analyticsKey);

      if (analyticsJson != null) {
        _analyticsData = PermissionAnalyticsData.fromJson(jsonDecode(analyticsJson));
      }
    } catch (e) {
      // å¤„ç†é”™è¯¯
    }
  }

  // ä¿å­˜åˆ†ææ•°æ®
  Future<void> _saveAnalyticsData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      if (_analyticsData != null) {
        await prefs.setString(_analyticsKey, jsonEncode(_analyticsData!.toJson()));
      }
    } catch (e) {
      // å¤„ç†é”™è¯¯
    }
  }

  // åŠ è½½äº‹ä»¶
  Future<void> _loadEvents() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final eventsJson = prefs.getString(_eventsKey);

      if (eventsJson != null) {
        final eventsList = jsonDecode(eventsJson) as List;
        _events = eventsList.map((e) => PermissionAnalyticsEvent.fromJson(e)).toList();
      }
    } catch (e) {
      // å¤„ç†é”™è¯¯
    }
  }

  // ä¿å­˜äº‹ä»¶
  Future<void> _saveEvents() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_eventsKey, jsonEncode(_events.map((e) => e.toJson()).toList()));
    } catch (e) {
      // å¤„ç†é”™è¯¯
    }
  }

  // æ›´æ–°åˆ†ææ•°æ®
  Future<void> _updateAnalyticsData() async {
    try {
      _analyticsData = PermissionAnalyticsData(
        totalEvents: _events.length,
        lastUpdated: DateTime.now(),
        requestCount: _events.where((e) => e.type == PermissionAnalyticsEventType.request).length,
        usageCount: _events.where((e) => e.type == PermissionAnalyticsEventType.usage).length,
        denialCount: _events.where((e) => e.type == PermissionAnalyticsEventType.denial).length,
      );

      await _saveAnalyticsData();
    } catch (e) {
      // å¤„ç†é”™è¯¯
    }
  }
}

// æƒé™åˆ†æäº‹ä»¶
class PermissionAnalyticsEvent {
  final PermissionAnalyticsEventType type;
  final Permission permission;
  final PermissionStatus? status;
  final DateTime timestamp;
  final Duration? usageDuration;
  final String? reason;
  final String? context;

  PermissionAnalyticsEvent({
    required this.type,
    required this.permission,
    this.status,
    required this.timestamp,
    this.usageDuration,
    this.reason,
    this.context,
  });

  Map<String, dynamic> toJson() {
    return {
      'type': type.index,
      'permission': permission.toString(),
      'status': status?.index,
      'timestamp': timestamp.toIso8601String(),
      'usageDuration': usageDuration?.inMilliseconds,
      'reason': reason,
      'context': context,
    };
  }

  factory PermissionAnalyticsEvent.fromJson(Map<String, dynamic> json) {
    return PermissionAnalyticsEvent(
      type: PermissionAnalyticsEventType.values[json['type']],
      permission: _parsePermission(json['permission']),
      status: json['status'] != null ? PermissionStatus.values[json['status']] : null,
      timestamp: DateTime.parse(json['timestamp']),
      usageDuration: json['usageDuration'] != null ? Duration(milliseconds: json['usageDuration']) : null,
      reason: json['reason'],
      context: json['context'],
    );
  }

  static Permission _parsePermission(String permissionString) {
    switch (permissionString) {
      case 'Permission.camera':
        return Permission.camera;
      case 'Permission.microphone':
        return Permission.microphone;
      case 'Permission.storage':
        return Permission.storage;
      case 'Permission.photos':
        return Permission.photos;
      case 'Permission.location':
        return Permission.location;
      case 'Permission.contacts':
        return Permission.contacts;
      case 'Permission.phone':
        return Permission.phone;
      case 'Permission.sms':
        return Permission.sms;
      case 'Permission.calendar':
        return Permission.calendar;
      case 'Permission.sensors':
        return Permission.sensors;
      case 'Permission.bluetooth':
        return Permission.bluetooth;
      case 'Permission.nfc':
        return Permission.nfc;
      case 'Permission.notification':
        return Permission.notification;
      default:
        return Permission.unknown;
    }
  }
}

// æƒé™åˆ†æäº‹ä»¶ç±»å‹
enum PermissionAnalyticsEventType {
  request,
  usage,
  denial,
}

// æƒé™åˆ†ææ•°æ®
class PermissionAnalyticsData {
  final int totalEvents;
  final DateTime lastUpdated;
  final int requestCount;
  final int usageCount;
  final int denialCount;

  PermissionAnalyticsData({
    required this.totalEvents,
    required this.lastUpdated,
    required this.requestCount,
    required this.usageCount,
    required this.denialCount,
  });

  Map<String, dynamic> toJson() {
    return {
      'totalEvents': totalEvents,
      'lastUpdated': lastUpdated.toIso8601String(),
      'requestCount': requestCount,
      'usageCount': usageCount,
      'denialCount': denialCount,
    };
  }

  factory PermissionAnalyticsData.fromJson(Map<String, dynamic> json) {
    return PermissionAnalyticsData(
      totalEvents: json['totalEvents'],
      lastUpdated: DateTime.parse(json['lastUpdated']),
      requestCount: json['requestCount'],
      usageCount: json['usageCount'],
      denialCount: json['denialCount'],
    );
  }
}

// æƒé™è¯·æ±‚ç»Ÿè®¡
class PermissionRequestStatistics {
  final Permission permission;
  int requestCount;
  int grantCount;
  int denialCount;
  DateTime lastRequestTime;

  PermissionRequestStatistics({
    required this.permission,
    required this.requestCount,
    required this.grantCount,
    required this.denialCount,
    required this.lastRequestTime,
  });

  // è·å–æˆæƒç‡
  double get grantRate {
    if (requestCount == 0) return 0.0;
    return grantCount / requestCount;
  }

  // è·å–æ ¼å¼åŒ–çš„æˆæƒç‡
  String get formattedGrantRate {
    return '${(grantRate * 100).toStringAsFixed(1)}%';
  }
}

// æƒé™ä½¿ç”¨ç»Ÿè®¡
class PermissionUsageStatistics {
  final Permission permission;
  int usageCount;
  Duration totalUsageDuration;
  DateTime lastUsageTime;

  PermissionUsageStatistics({
    required this.permission,
    required this.usageCount,
    required this.totalUsageDuration,
    required this.lastUsageTime,
  });

  // è·å–å¹³å‡ä½¿ç”¨æ—¶é•¿
  Duration get averageUsageDuration {
    if (usageCount == 0) return Duration.zero;
    return Duration(milliseconds: totalUsageDuration.inMilliseconds ~/ usageCount);
  }

  // è·å–æ ¼å¼åŒ–çš„æ€»ä½¿ç”¨æ—¶é•¿
  String get formattedTotalUsageDuration {
    final hours = totalUsageDuration.inHours;
    final minutes = totalUsageDuration.inMinutes % 60;
    final seconds = totalUsageDuration.inSeconds % 60;

    if (hours > 0) {
      return '${hours}å°æ—¶${minutes}åˆ†é’Ÿ';
    } else if (minutes > 0) {
      return '${minutes}åˆ†é’Ÿ${seconds}ç§’';
    } else {
      return '${seconds}ç§’';
    }
  }
}

// æƒé™æ‹’ç»åˆ†æ
class PermissionDenialAnalysis {
  final int totalDenials;
  final Map<String, int> denialReasons;
  final Map<Permission, int> permissionDenials;
  final String mostCommonReason;
  final Permission mostDeniedPermission;

  PermissionDenialAnalysis({
    required this.totalDenials,
    required this.denialReasons,
    required this.permissionDenials,
    required this.mostCommonReason,
    required this.mostDeniedPermission,
  });
}

// æƒé™è¶‹åŠ¿åˆ†æ
class PermissionTrendAnalysis {
  final Duration period;
  final Map<DateTime, PermissionTrendData> trendData;
  final DateTime startDate;
  final DateTime endDate;

  PermissionTrendAnalysis({
    required this.period,
    required this.trendData,
    required this.startDate,
    required this.endDate,
  });
}

// æƒé™è¶‹åŠ¿æ•°æ®
class PermissionTrendData {
  final DateTime date;
  final int requestCount;
  final int grantCount;
  final int denialCount;
  final int usageCount;

  PermissionTrendData({
    required this.date,
    required this.requestCount,
    required this.grantCount,
    required this.denialCount,
    required this.usageCount,
  });

  // è·å–æˆæƒç‡
  double get grantRate {
    if (requestCount == 0) return 0.0;
    return grantCount / requestCount;
  }
}

// æƒé™æŠ¥å‘Š
class PermissionReport {
  final DateTime generatedAt;
  final Duration period;
  final Map<Permission, PermissionRequestStatistics> requestStatistics;
  final Map<Permission, PermissionUsageStatistics> usageStatistics;
  final PermissionDenialAnalysis denialAnalysis;
  final PermissionTrendAnalysis trendAnalysis;

  PermissionReport({
    required this.generatedAt,
    required this.period,
    required this.requestStatistics,
    required this.usageStatistics,
    required this.denialAnalysis,
    required this.trendAnalysis,
  });

  // å¯¼å‡ºä¸ºJSON
  String toJson() {
    return jsonEncode({
      'generatedAt': generatedAt.toIso8601String(),
      'period': period.inDays,
      'requestStatistics': requestStatistics.map((key, value) => MapEntry(key.toString(), {
        'requestCount': value.requestCount,
        'grantCount': value.grantCount,
        'denialCount': value.denialCount,
        'grantRate': value.grantRate,
        'lastRequestTime': value.lastRequestTime.toIso8601String(),
      })),
      'usageStatistics': usageStatistics.map((key, value) => MapEntry(key.toString(), {
        'usageCount': value.usageCount,
        'totalUsageDuration': value.totalUsageDuration.inMilliseconds,
        'averageUsageDuration': value.averageUsageDuration.inMilliseconds,
        'lastUsageTime': value.lastUsageTime.toIso8601String(),
      })),
      'denialAnalysis': {
        'totalDenials': denialAnalysis.totalDenials,
        'denialReasons': denialAnalysis.denialReasons,
        'mostCommonReason': denialAnalysis.mostCommonReason,
        'mostDeniedPermission': denialAnalysis.mostDeniedPermission.toString(),
      },
      'trendAnalysis': {
        'period': trendAnalysis.period.inDays,
        'startDate': trendAnalysis.startDate.toIso8601String(),
        'endDate': trendAnalysis.endDate.toIso8601String(),
        'trendData': trendAnalysis.trendData.map((key, value) => MapEntry(key.toIso8601String(), {
          'requestCount': value.requestCount,
          'grantCount': value.grantCount,
          'denialCount': value.denialCount,
          'usageCount': value.usageCount,
          'grantRate': value.grantRate,
        })),
      },
    });
  }
}

// æƒé™åˆ†æå¼‚å¸¸
class PermissionAnalyticsException implements Exception {
  final String message;
  PermissionAnalyticsException(this.message);

  @override
  String toString() => message;
}
```

## æµ‹è¯•ä¸è°ƒè¯•

### 1. æƒé™æœåŠ¡æµ‹è¯•

```dart
// test/permission_service_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:secure_app/services/permission_service.dart';

void main() {
  group('PermissionService Tests', () {
    late PermissionService permissionService;

    setUp(() {
      permissionService = PermissionService();
    });

    test('should initialize successfully', () async {
      await expectLater(permissionService.initialize(), completes);
    });

    test('should check permission status correctly', () async {
      final status = await permissionService.checkPermissionStatus(Permission.camera);
      expect(status, isA<PermissionStatus>());
    });

    test('should request permission correctly', () async {
      final status = await permissionService.requestPermission(Permission.camera);
      expect(status, isA<PermissionStatus>());
    });

    test('should request multiple permissions correctly', () async {
      final result = await permissionService.requestPermissions([
        Permission.camera,
        Permission.microphone,
      ]);
      expect(result, isA<PermissionRequestResult>());
    });

    test('should check if permission is permanently denied', () async {
      final isPermanentlyDenied = await permissionService.isPermanentlyDenied(Permission.camera);
      expect(isPermanentlyDenied, isA<bool>());
    });

    test('should open app settings correctly', () async {
      await expectLater(permissionService.openAppSettings(), completes);
    });
  });
}
```

### 2. æƒé™ç›‘æ§æœåŠ¡æµ‹è¯•

```dart
// test/permission_monitor_service_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:secure_app/services/permission_monitor_service.dart';

void main() {
  group('PermissionMonitorService Tests', () {
    late PermissionMonitorService monitorService;

    setUp(() {
      monitorService = PermissionMonitorService();
    });

    test('should start monitoring correctly', () {
      monitorService.startMonitoring();
      expect(monitorService.monitorEventStream, isA<Stream>());
    });

    test('should stop monitoring correctly', () {
      monitorService.startMonitoring();
      monitorService.stopMonitoring();
      // éªŒè¯ç›‘æ§å·²åœæ­¢
    });

    test('should get permission usage statistics correctly', () async {
      final statistics = await monitorService.getPermissionUsageStatistics();
      expect(statistics, isA<PermissionUsageStatistics>());
    });

    test('should get permission security assessment correctly', () async {
      final assessment = await monitorService.getPermissionSecurityAssessment();
      expect(assessment, isA<PermissionSecurityAssessment>());
    });
  });
}
```

## æœ€ä½³å®è·µä¸æ³¨æ„äº‹é¡¹

### 1. æƒé™ç”³è¯·ç­–ç•¥

- **æ¸è¿›å¼ç”³è¯·**ï¼šæŒ‰éœ€ç”³è¯·æƒé™ï¼Œé¿å…ä¸€æ¬¡æ€§ç”³è¯·è¿‡å¤šæƒé™
- **æƒé™è¯´æ˜**ï¼šåœ¨ç”³è¯·æƒé™å‰æä¾›æ¸…æ™°çš„è¯´æ˜
- **æ—¶æœºé€‰æ‹©**ï¼šåœ¨ç”¨æˆ·éœ€è¦ç›¸å…³åŠŸèƒ½æ—¶å†ç”³è¯·æƒé™
- **ä¼˜é›…é™çº§**ï¼šåœ¨æƒé™è¢«æ‹’ç»æ—¶æä¾›æ›¿ä»£åŠŸèƒ½

### 2. ç”¨æˆ·ä½“éªŒä¼˜åŒ–

- **æƒé™çŠ¶æ€å¯è§†åŒ–**ï¼šæ¸…æ™°å±•ç¤ºæƒé™çŠ¶æ€
- **æƒé™å¼•å¯¼**ï¼šæä¾›æƒé™ç”³è¯·å¼•å¯¼å’Œè¯´æ˜
- **è®¾ç½®è·³è½¬**ï¼šæ–¹ä¾¿ç”¨æˆ·è·³è½¬åˆ°è®¾ç½®é¡µé¢
- **çŠ¶æ€åŒæ­¥**ï¼šåŠæ—¶åŒæ­¥æƒé™çŠ¶æ€å˜åŒ–

### 3. å®‰å…¨è€ƒè™‘

- **æœ€å°æƒé™åŸåˆ™**ï¼šåªç”³è¯·å¿…è¦çš„æƒé™
- **æƒé™å®¡è®¡**ï¼šå®šæœŸå®¡è®¡æƒé™ä½¿ç”¨æƒ…å†µ
- **æ•°æ®ä¿æŠ¤**ï¼šä¿æŠ¤ç”¨æˆ·éšç§æ•°æ®
- **æƒé™ç›‘æ§**ï¼šç›‘æ§æƒé™å¼‚å¸¸ä½¿ç”¨

### 4. å¹³å°å·®å¼‚å¤„ç†

- **API å·®å¼‚**ï¼šå¤„ç† Android å’Œ iOS å¹³å° API å·®å¼‚
- **æƒé™ç±»å‹**ï¼šäº†è§£ä¸åŒå¹³å°çš„æƒé™ç±»å‹
- **ç”³è¯·æµç¨‹**ï¼šé€‚é…ä¸åŒå¹³å°çš„ç”³è¯·æµç¨‹
- **çŠ¶æ€æ˜ å°„**ï¼šç»Ÿä¸€ä¸åŒå¹³å°çš„æƒé™çŠ¶æ€

### 5. é”™è¯¯å¤„ç†

- **å¼‚å¸¸æ•è·**ï¼šæ•è·æƒé™ç”³è¯·å¼‚å¸¸
- **é‡è¯•æœºåˆ¶**ï¼šæä¾›æƒé™ç”³è¯·é‡è¯•æœºåˆ¶
- **ç”¨æˆ·åé¦ˆ**ï¼šæä¾›æ¸…æ™°çš„é”™è¯¯åé¦ˆ
- **æ—¥å¿—è®°å½•**ï¼šè®°å½•æƒé™ç›¸å…³æ—¥å¿—

## æ€»ç»“

é€šè¿‡æœ¬æ–‡çš„è¯¦ç»†ä»‹ç»ï¼Œæˆ‘ä»¬æˆåŠŸå®ç°äº†ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„å®‰å…¨æƒé™ç®¡ç†åº”ç”¨ SecureAppã€‚è¿™ä¸ªé¡¹ç›®æ¶µç›–äº†ï¼š

1. **æƒé™ç®¡ç†åŸºç¡€**ï¼šå…¨é¢çš„æƒé™ç”³è¯·å’Œç®¡ç†åŠŸèƒ½
2. **æƒé™ç›‘æ§**ï¼šå®æ—¶ç›‘æ§æƒé™çŠ¶æ€å˜åŒ–
3. **æƒé™åˆ†æ**ï¼šæ·±åº¦åˆ†ææƒé™ä½¿ç”¨æƒ…å†µ
4. **æƒé™å®‰å…¨**ï¼šæƒé™å®‰å…¨è¯„ä¼°å’Œé£é™©åˆ†æ
5. **æƒé™æŠ¥å‘Š**ï¼šç”Ÿæˆè¯¦ç»†çš„æƒé™ä½¿ç”¨æŠ¥å‘Š
6. **è·¨å¹³å°æ”¯æŒ**ï¼šåŒæ—¶æ”¯æŒ Android å’Œ iOS å¹³å°

æƒé™ç®¡ç†æ˜¯ç§»åŠ¨åº”ç”¨å¼€å‘ä¸­çš„é‡è¦ç¯èŠ‚ï¼Œé€šè¿‡ Flutter çš„æƒé™ç®¡ç†èƒ½åŠ›ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾å®ç°è·¨å¹³å°çš„æƒé™ç”³è¯·å’Œç®¡ç†ã€‚åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¿˜å¯ä»¥æ ¹æ®å…·ä½“éœ€æ±‚è¿›ä¸€æ­¥æ‰©å±•åŠŸèƒ½ï¼Œæ¯”å¦‚ï¼š

- é›†æˆæ›´å¤šæƒé™ç±»å‹
- æ·»åŠ æƒé™ç”³è¯·æ¨¡æ¿
- å®ç°æƒé™ç”³è¯·è‡ªåŠ¨åŒ–
- é›†æˆæƒé™åˆè§„æ£€æŸ¥
- æ·»åŠ æƒé™ä½¿ç”¨é¢„æµ‹
- å®ç°æƒé™ç”³è¯·ä¼˜åŒ–å»ºè®®

å¸Œæœ›æœ¬æ–‡èƒ½å¤Ÿå¸®åŠ©å¼€å‘è€…æ›´å¥½åœ°ç†è§£å’Œå®ç° Flutter ä¸­çš„æƒé™ç®¡ç†åŠŸèƒ½ã€‚
